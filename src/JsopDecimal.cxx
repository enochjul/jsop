//This Source Code Form is subject to the terms of the Mozilla Public
//License, v. 2.0. If a copy of the MPL was not distributed with this
//file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "JsopDecimal.h"

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stddef.h>

#ifndef JSOP_USE_CLZ
	#if !defined(__i386__) && !defined(__amd64__)
		#define JSOP_USE_CLZ
	#endif
#endif

#ifndef JSOP_USE_CLZ
#include <x86intrin.h>
#endif

#include "JsopDefines.h"
#include "JsopDecimal.h"

#define JSOP_MPN_MAX_UINTS (1024 / JSOP_WORD_SIZE)

#define JSOP_MAX_EXPONENT_OF_FIVE 308

#ifdef JSOP_USE_FP_MATH

static const double JsopPowersOfTen[] = {
	1.e0,
	1.e1,
	1.e2,
	1.e3,
	1.e4,
	1.e5,
	1.e6,
	1.e7,
	1.e8,
	1.e9,
	1.e10,
	1.e11,
	1.e12,
	1.e13,
	1.e14,
	1.e15,
	1.e16,
	1.e17,
	1.e18,
	1.e19,
	1.e20,
	1.e21,
	1.e22,
};

#endif

#if JSOP_WORD_SIZE == 64

#define JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE_BITS 4
#define JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE (1 << JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE_BITS)

static const uint64_t JsopSmallPowersOfFive[] = {
	UINT64_C(1),	//5e0 at: 0
	UINT64_C(5),	//5e1 at: 1
	UINT64_C(25),	//5e2 at: 2
	UINT64_C(125),	//5e3 at: 3
	UINT64_C(625),	//5e4 at: 4
	UINT64_C(3125),	//5e5 at: 5
	UINT64_C(15625),	//5e6 at: 6
	UINT64_C(78125),	//5e7 at: 7
	UINT64_C(390625),	//5e8 at: 8
	UINT64_C(1953125),	//5e9 at: 9
	UINT64_C(9765625),	//5e10 at: 10
	UINT64_C(48828125),	//5e11 at: 11
	UINT64_C(244140625),	//5e12 at: 12
	UINT64_C(1220703125),	//5e13 at: 13
	UINT64_C(6103515625),	//5e14 at: 14
	UINT64_C(30517578125),	//5e15 at: 15
	//The following entries are used when the exponent is small and there is no need
	//for full multi-precision arithmetic
	UINT64_C(152587890625),	//5e16 at: 16
	UINT64_C(762939453125),	//5e17 at: 17
	UINT64_C(3814697265625),	//5e18 at: 18
	UINT64_C(19073486328125),	//5e19 at: 19
	UINT64_C(95367431640625),	//5e20 at: 20
	UINT64_C(476837158203125),	//5e21 at: 21
	UINT64_C(2384185791015625),	//5e22 at: 22
	UINT64_C(11920928955078125),	//5e23 at: 23
	UINT64_C(59604644775390625),	//5e24 at: 24
	UINT64_C(298023223876953125),	//5e25 at: 25
	UINT64_C(1490116119384765625),	//5e26 at: 26
	UINT64_C(7450580596923828125),	//5e27 at: 27
};

static const uint64_t JsopLargePowersOfFive[] = {
	UINT64_C(152587890625),	//5e16 at: 0
	UINT64_C(3273344365508751233),	//5e32 at: 1
	UINT64_C(1262),
	UINT64_C(10796982567420264257),	//5e48 at: 3
	UINT64_C(192592994438723),
	UINT64_C(7942358959831785217),	//5e64 at: 5
	UINT64_C(16807427164405733357),
	UINT64_C(1593091),
	UINT64_C(1786349750302592705),	//5e80 at: 8
	UINT64_C(17253516472054312868),
	UINT64_C(243086534291450847),
	UINT64_C(16463104408102080129),	//5e96 at: 11
	UINT64_C(8787939108875325466),
	UINT64_C(7119498668098974887),
	UINT64_C(2010764683),
	UINT64_C(3381057891661143617),	//5e112 at: 15
	UINT64_C(10735983596622975722),
	UINT64_C(8960454036513601038),
	UINT64_C(11670436401755083712),
	UINT64_C(16),
	UINT64_C(279109966635548161),	//5e128 at: 20
	UINT64_C(2554917779393558781),
	UINT64_C(14124656261812188652),
	UINT64_C(11976055582626787546),
	UINT64_C(2537941837315),
	UINT64_C(13142907561237294529),	//5e144 at: 25
	UINT64_C(15012915935620909864),
	UINT64_C(8626481361138331845),
	UINT64_C(1168207125790530789),
	UINT64_C(6693145547210207115),
	UINT64_C(20993),
	UINT64_C(5918522610932723073),	//5e160 at: 31
	UINT64_C(6274625834419431504),
	UINT64_C(15436471992936698899),
	UINT64_C(41157043676584345),
	UINT64_C(8837601482497004758),
	UINT64_C(3203332952292961),
	UINT64_C(3739996296477556033),	//5e176 at: 37
	UINT64_C(10351898152832247795),
	UINT64_C(13841419836910763695),
	UINT64_C(18311852890016993852),
	UINT64_C(16863622950885146403),
	UINT64_C(2525173035325650718),
	UINT64_C(26497349),
	UINT64_C(12241203936672963841),	//5e192 at: 44
	UINT64_C(8547193819338301733),
	UINT64_C(18349701731253264454),
	UINT64_C(8335547191915630412),
	UINT64_C(14106508276975308012),
	UINT64_C(11632508206330070277),
	UINT64_C(4043174611952194906),
	UINT64_C(4367455660591058113),	//5e208 at: 51
	UINT64_C(16548313580814331792),
	UINT64_C(4321648130621879828),
	UINT64_C(13547454815450313946),
	UINT64_C(6048736007087622621),
	UINT64_C(7420898731738094924),
	UINT64_C(13552186893076320950),
	UINT64_C(33444356521),
	UINT64_C(4777629371499269249),	//5e224 at: 59
	UINT64_C(18001405160525099782),
	UINT64_C(4879812164015670080),
	UINT64_C(14509320244552862897),
	UINT64_C(2636856509737464972),
	UINT64_C(2417179124242652079),
	UINT64_C(8851510277453438840),
	UINT64_C(11902450618118332165),
	UINT64_C(276),
	UINT64_C(12562630731880668225),	//5e240 at: 68
	UINT64_C(18148925004990573666),
	UINT64_C(13687028476692182690),
	UINT64_C(3188046834748633958),
	UINT64_C(7208039433865641912),
	UINT64_C(7642104988810794228),
	UINT64_C(4308327305980438358),
	UINT64_C(14256543960517867562),
	UINT64_C(42212712576431),
	UINT64_C(13750482914757213185),	//5e256 at: 77
	UINT64_C(1302999927698857842),
	UINT64_C(14936872543252795590),
	UINT64_C(2788415840139466767),
	UINT64_C(2095640732773017264),
	UINT64_C(7205570348933370714),
	UINT64_C(7348167152523113408),
	UINT64_C(9285516396840364274),
	UINT64_C(6907659600622710236),
	UINT64_C(349175),
	UINT64_C(5315065625431894977),	//5e272 at: 87
	UINT64_C(9314130467072152725),
	UINT64_C(10025403145359357349),
	UINT64_C(18286149486344847958),
	UINT64_C(4844151787336583626),
	UINT64_C(4545084181093574900),
	UINT64_C(12194420911872105142),
	UINT64_C(1769952130372526753),
	UINT64_C(9388647902887847758),
	UINT64_C(53279933847805372),
	UINT64_C(792478769211075457),	//5e288 at: 97
	UINT64_C(9511335878798620707),
	UINT64_C(12802697721526339408),
	UINT64_C(9401145187231568770),
	UINT64_C(9023980117402305551),
	UINT64_C(4069250660416542207),
	UINT64_C(2180080595215225784),
	UINT64_C(16801844099710515453),
	UINT64_C(10232149913123443095),
	UINT64_C(3138241419126269405),
	UINT64_C(440721283),
	UINT64_C(9460753007646669633),	//5e304 at: 108
	UINT64_C(4101240109067166068),
	UINT64_C(4318227663976943808),
	UINT64_C(13679571461471155550),
	UINT64_C(14606445316381517945),
	UINT64_C(2797963276364370362),
	UINT64_C(12008763709573679603),
	UINT64_C(3508196504893670642),
	UINT64_C(13255565951930391271),
	UINT64_C(2241350861767344549),
	UINT64_C(11908498731343941621),
	UINT64_C(3),
	UINT64_C(14401576960375167745),	//5e320 at: 120
	UINT64_C(8342440259312528684),
	UINT64_C(5880478486118623184),
	UINT64_C(11552544083348288248),
	UINT64_C(4937479739776443194),
	UINT64_C(8108476058741955002),
	UINT64_C(16551382738316049051),
	UINT64_C(13712799161325714254),
	UINT64_C(10115908636764788705),
	UINT64_C(15304990897611598971),
	UINT64_C(14763773636856087296),
	UINT64_C(556268464626),
	UINT64_C(2343036402624121537),	//5e336 at: 132
	UINT64_C(15712293936921064210),
	UINT64_C(9685200040091611846),
	UINT64_C(1824876561096011938),
	UINT64_C(3033007227748009068),
	UINT64_C(7697817146613520910),
	UINT64_C(14734893084814930886),
	UINT64_C(15135274020250680270),
	UINT64_C(16521098470741304709),
	UINT64_C(899335150196869773),
	UINT64_C(5323629405605868178),
	UINT64_C(6362155473245619239),
	UINT64_C(4601),
};

static const uint8_t JsopLargePowersOfFiveOffsets[] = {
	0,
	1,
	3,
	5,
	8,
	11,
	15,
	20,
	25,
	31,
	37,
	44,
	51,
	59,
	68,
	77,
	87,
	97,
	108,
	120,
	132,
	145,
};

static const uint64_t JsopNormalizedReciprocalsOf5[] = {
	UINT64_C(0xcccccccccccccccc),
	UINT64_C(0xa3d70a3d70a3d70a),
	UINT64_C(0x83126e978d4fdf3b),
	UINT64_C(0xd1b71758e219652b),
	UINT64_C(0xa7c5ac471b478423),
	UINT64_C(0x8637bd05af6c69b5),
	UINT64_C(0xd6bf94d5e57a42bc),
	UINT64_C(0xabcc77118461cefc),
	UINT64_C(0x89705f4136b4a597),
	UINT64_C(0xdbe6fecebdedd5be),
	UINT64_C(0xafebff0bcb24aafe),
	UINT64_C(0x8cbccc096f5088cb),
	UINT64_C(0xe12e13424bb40e13),
	UINT64_C(0xb424dc35095cd80f),
	UINT64_C(0x901d7cf73ab0acd9),
	UINT64_C(0xe69594bec44de15b),
	UINT64_C(0xb877aa3236a4b449),
	UINT64_C(0x9392ee8e921d5d07),
	UINT64_C(0xec1e4a7db69561a5),
	UINT64_C(0xbce5086492111aea),
	UINT64_C(0x971da05074da7bee),
	UINT64_C(0xf1c90080baf72cb1),
	UINT64_C(0xc16d9a0095928a27),
	UINT64_C(0x9abe14cd44753b52),
	UINT64_C(0xf79687aed3eec551),
	UINT64_C(0xc612062576589dda),
	UINT64_C(0x9e74d1b791e07e48),
	UINT64_C(0xfd87b5f28300ca0d),
	UINT64_C(0xcad2f7f5359a3b3e),
	UINT64_C(0xa2425ff75e14fc31),
	UINT64_C(0x81ceb32c4b43fcf4),
	UINT64_C(0xcfb11ead453994ba),
	UINT64_C(0xa6274bbdd0fadd61),
	UINT64_C(0x84ec3c97da624ab4),
	UINT64_C(0xd4ad2dbfc3d07787),
	UINT64_C(0xaa242499697392d2),
	UINT64_C(0x881cea14545c7575),
	UINT64_C(0xd9c7dced53c72255),
	UINT64_C(0xae397d8aa96c1b77),
	UINT64_C(0x8b61313bbabce2c6),
	UINT64_C(0xdf01e85f912e37a3),
	UINT64_C(0xb267ed1940f1c61c),
	UINT64_C(0x8eb98a7a9a5b04e3),
	UINT64_C(0xe45c10c42a2b3b05),
	UINT64_C(0xb6b00d69bb55c8d1),
	UINT64_C(0x9226712162ab070d),
	UINT64_C(0xe9d71b689dde71af),
	UINT64_C(0xbb127c53b17ec159),
	UINT64_C(0x95a8637627989aad),
	UINT64_C(0xef73d256a5c0f77c),
	UINT64_C(0xbf8fdb78849a5f96),
	UINT64_C(0x993fe2c6d07b7fab),
	UINT64_C(0xf53304714d9265df),
	UINT64_C(0xc428d05aa4751e4c),
	UINT64_C(0x9ced737bb6c4183d),
	UINT64_C(0xfb158592be068d2e),
	UINT64_C(0xc8de047564d20a8b),
	UINT64_C(0xa0b19d2ab70e6ed6),
	UINT64_C(0x808e17555f3ebf11),
	UINT64_C(0xcdb02555653131b6),
	UINT64_C(0xa48ceaaab75a8e2b),
	UINT64_C(0x83a3eeeef9153e89),
	UINT64_C(0xd29fe4b18e88640e),
	UINT64_C(0xa87fea27a539e9a5),
	UINT64_C(0x86ccbb52ea94baea),
	UINT64_C(0xd7adf884aa879177),
	UINT64_C(0xac8b2d36eed2dac5),
	UINT64_C(0x8a08f0f8bf0f156b),
	UINT64_C(0xdcdb1b2798182244),
	UINT64_C(0xb0af48ec79ace837),
	UINT64_C(0x8d590723948a535f),
	UINT64_C(0xe2280b6c20dd5232),
	UINT64_C(0xb4ecd5f01a4aa828),
	UINT64_C(0x90bd77f3483bb9b9),
	UINT64_C(0xe7958cb87392c2c2),
	UINT64_C(0xb94470938fa89bce),
	UINT64_C(0x9436c0760c86e30b),
	UINT64_C(0xed246723473e3813),
	UINT64_C(0xbdb6b8e905cb600f),
	UINT64_C(0x97c560ba6b0919a5),
	UINT64_C(0xf2d56790ab41c2a2),
	UINT64_C(0xc24452da229b021b),
	UINT64_C(0x9b69dbe1b548ce7c),
	UINT64_C(0xf8a95fcf88747d94),
	UINT64_C(0xc6ede63fa05d3143),
	UINT64_C(0x9f24b832e6b0f436),
	UINT64_C(0xfea126b7d78186bc),
	UINT64_C(0xcbb41ef979346bca),
	UINT64_C(0xa2f67f2dfa90563b),
	UINT64_C(0x825ecc24c873782f),
	UINT64_C(0xd097ad07a71f26b2),
	UINT64_C(0xa6dfbd9fb8e5b88e),
	UINT64_C(0x857fcae62d8493a5),
	UINT64_C(0xd59944a37c0752a2),
	UINT64_C(0xaae103b5fcd2a881),
	UINT64_C(0x88b402f7fd75539b),
	UINT64_C(0xdab99e59958885c4),
	UINT64_C(0xaefae51477a06b03),
	UINT64_C(0x8bfbea76c619ef36),
	UINT64_C(0xdff9772470297ebd),
	UINT64_C(0xb32df8e9f3546564),
	UINT64_C(0x8f57fa54c2a9eab6),
	UINT64_C(0xe55990879ddcaabd),
	UINT64_C(0xb77ada0617e3bbcb),
	UINT64_C(0x92c8ae6b464fc96f),
	UINT64_C(0xeadab0aba3b2dbe5),
	UINT64_C(0xbbe226efb628afea),
	UINT64_C(0x964e858c91ba2655),
	UINT64_C(0xf07da27a82c37088),
	UINT64_C(0xc06481fb9bcf8d39),
	UINT64_C(0x99ea0196163fa42e),
	UINT64_C(0xf64335bcf065d37d),
	UINT64_C(0xc5029163f384a931),
	UINT64_C(0x9d9ba7832936edc0),
	UINT64_C(0xfc2c3f3841f17c67),
	UINT64_C(0xc9bcff6034c13052),
	UINT64_C(0xa163ff802a3426a8),
	UINT64_C(0x811ccc668829b887),
	UINT64_C(0xce947a3da6a9273e),
	UINT64_C(0xa54394fe1eedb8fe),
	UINT64_C(0x843610cb4bf160cb),
	UINT64_C(0xd389b47879823479),
	UINT64_C(0xa93af6c6c79b5d2d),
	UINT64_C(0x87625f056c7c4a8b),
	UINT64_C(0xd89d64d57a607744),
	UINT64_C(0xad4ab7112eb3929d),
	UINT64_C(0x8aa22c0dbef60ee4),
	UINT64_C(0xddd0467c64bce4a0),
	UINT64_C(0xb1736b96b6fd83b3),
	UINT64_C(0x8df5efabc5979c8f),
	UINT64_C(0xe3231912d5bf60e6),
	UINT64_C(0xb5b5ada8aaff80b8),
	UINT64_C(0x915e2486ef32cd60),
	UINT64_C(0xe896a0d7e51e1566),
	UINT64_C(0xba121a4650e4ddeb),
	UINT64_C(0x94db483840b717ef),
	UINT64_C(0xee2ba6c0678b597f),
	UINT64_C(0xbe89523386091465),
	UINT64_C(0x986ddb5c6b3a76b7),
	UINT64_C(0xf3e2f893dec3f126),
	UINT64_C(0xc31bfa0fe5698db8),
	UINT64_C(0x9c1661a651213e2d),
	UINT64_C(0xf9bd690a1b68637b),
	UINT64_C(0xc7caba6e7c5382c8),
	UINT64_C(0x9fd561f1fd0f9bd3),
	UINT64_C(0xffbbcfe994e5c61f),
	UINT64_C(0xcc963fee10b7d1b3),
	UINT64_C(0xa3ab66580d5fdaf5),
	UINT64_C(0x82ef85133de648c4),
	UINT64_C(0xd17f3b51fca3a7a0),
	UINT64_C(0xa798fc4196e952e7),
	UINT64_C(0x8613fd0145877585),
	UINT64_C(0xd686619ba27255a2),
	UINT64_C(0xab9eb47c81f5114f),
	UINT64_C(0x894bc396ce5da772),
	UINT64_C(0xdbac6c247d62a583),
	UINT64_C(0xafbd2350644eeacf),
	UINT64_C(0x8c974f7383725573),
	UINT64_C(0xe0f218b8d25088b8),
	UINT64_C(0xb3f4e093db73a093),
	UINT64_C(0x8ff71a0fe2c2e6dc),
	UINT64_C(0xe65829b3046b0afa),
	UINT64_C(0xb84687c269ef3bfb),
	UINT64_C(0x936b9fcebb25c995),
	UINT64_C(0xebdf661791d60f56),
	UINT64_C(0xbcb2b812db11a5de),
	UINT64_C(0x96f5600f15a7b7e5),
	UINT64_C(0xf18899b1bc3f8ca1),
	UINT64_C(0xc13a148e3032d6e7),
	UINT64_C(0x9a94dd3e8cf578b9),
	UINT64_C(0xf7549530e188c128),
	UINT64_C(0xc5dd44271ad3cdba),
	UINT64_C(0x9e4a9cec15763e2e),
	UINT64_C(0xfd442e4688bd304a),
	UINT64_C(0xca9cf1d206fdc03b),
	UINT64_C(0xa21727db38cb002f),
	UINT64_C(0x81ac1fe293d599bf),
	UINT64_C(0xcf79cc9db955c2cc),
	UINT64_C(0xa5fb0a17c777cf09),
	UINT64_C(0x84c8d4dfd2c63f3b),
	UINT64_C(0xd47487cc8470652b),
	UINT64_C(0xa9f6d30a038d1dbc),
	UINT64_C(0x87f8a8d4cfa417c9),
	UINT64_C(0xd98ddaee19068c76),
	UINT64_C(0xae0b158b4738705e),
	UINT64_C(0x8b3c113c38f9f37e),
	UINT64_C(0xdec681f9f4c31f31),
	UINT64_C(0xb23867fb2a35b28d),
	UINT64_C(0x8e938662882af53e),
	UINT64_C(0xe41f3d6a7377eeca),
	UINT64_C(0xb67f6455292cbf08),
	UINT64_C(0x91ff83775423cc06),
	UINT64_C(0xe998d258869facd7),
	UINT64_C(0xbae0a846d2195712),
	UINT64_C(0x9580869f0e7aac0e),
	UINT64_C(0xef340a98172aace4),
	UINT64_C(0xbf5cd54678eef0b6),
	UINT64_C(0x991711052d8bf3c5),
	UINT64_C(0xf4f1b4d515acb93b),
	UINT64_C(0xc3f490aa77bd60fc),
	UINT64_C(0x9cc3a6eec6311a63),
	UINT64_C(0xfad2a4b13d1b5d6c),
	UINT64_C(0xc8a883c0fdaf7df0),
	UINT64_C(0xa086cfcd97bf97f3),
	UINT64_C(0x806bd9714632dff6),
	UINT64_C(0xcd795be870516656),
	UINT64_C(0xa46116538d0deb78),
	UINT64_C(0x8380dea93da4bc60),
	UINT64_C(0xd267caa862a12d66),
	UINT64_C(0xa8530886b54dbdeb),
	UINT64_C(0x86a8d39ef77164bc),
	UINT64_C(0xd77485cb25823ac7),
	UINT64_C(0xac5d37d5b79b6239),
	UINT64_C(0x89e42caaf9491b60),
	UINT64_C(0xdca04777f541c567),
	UINT64_C(0xb080392cc4349dec),
	UINT64_C(0x8d3360f09cf6e4bd),
	UINT64_C(0xe1ebce4dc7f16dfb),
	UINT64_C(0xb4bca50b065abe63),
	UINT64_C(0x9096ea6f3848984f),
	UINT64_C(0xe757dd7ec07426e5),
	UINT64_C(0xb913179899f68584),
	UINT64_C(0x940f4613ae5ed136),
	UINT64_C(0xece53cec4a314ebd),
	UINT64_C(0xbd8430bd08277231),
	UINT64_C(0x979cf3ca6cec5b5a),
	UINT64_C(0xf294b943e17a2bc4),
	UINT64_C(0xc21094364dfb5636),
	UINT64_C(0x9b407691d7fc44f8),
	UINT64_C(0xf867241c8cc6d4c0),
	UINT64_C(0xc6b8e9b0709f109a),
	UINT64_C(0x9efa548d26e5a6e1),
	UINT64_C(0xfe5d54150b090b02),
	UINT64_C(0xcb7ddcdda26da268),
	UINT64_C(0xa2cb1717b52481ed),
	UINT64_C(0x823c12795db6ce57),
	UINT64_C(0xd0601d8efc57b08b),
	UINT64_C(0xa6b34ad8c9dfc06f),
	UINT64_C(0x855c3be0a17fcd26),
	UINT64_C(0xd5605fcdcf32e1d6),
	UINT64_C(0xaab37fd7d8f58178),
	UINT64_C(0x888f99797a5e012d),
	UINT64_C(0xda7f5bf590966848),
	UINT64_C(0xaecc49914078536d),
	UINT64_C(0x8bd6a141006042bd),
	UINT64_C(0xdfbdcece67006ac9),
	UINT64_C(0xb2fe3f0b8599ef07),
	UINT64_C(0x8f31cc0937ae58d2),
	UINT64_C(0xe51c79a85916f484),
	UINT64_C(0xb749faed14125d36),
	UINT64_C(0x92a1958a7675175f),
	UINT64_C(0xea9c227723ee8bcb),
	UINT64_C(0xbbb01b9283253ca2),
	UINT64_C(0x96267c7535b763b5),
	UINT64_C(0xf03d93eebc589f88),
	UINT64_C(0xc0314325637a1939),
	UINT64_C(0x99c102844f94e0fb),
	UINT64_C(0xf6019da07f549b2b),
	UINT64_C(0xc4ce17b399107c22),
	UINT64_C(0x9d71ac8fada6c9b5),
	UINT64_C(0xfbe9141915d7a922),
	UINT64_C(0xc987434744ac874e),
	UINT64_C(0xa139029f6a239f72),
	UINT64_C(0x80fa687f881c7f8e),
	UINT64_C(0xce5d73ff402d98e3),
	UINT64_C(0xa5178fff668ae0b6),
	UINT64_C(0x8412d9991ed58091),
	UINT64_C(0xd3515c2831559a83),
	UINT64_C(0xa90de3535aaae202),
	UINT64_C(0x873e4f75e2224e68),
	UINT64_C(0xd863b256369d4a40),
	UINT64_C(0xad1c8eab5ee43b66),
	UINT64_C(0x8a7d3eef7f1cfc52),
	UINT64_C(0xdd95317f31c7fa1d),
	UINT64_C(0xb1442798f49ffb4a),
	UINT64_C(0x8dd01fad907ffc3b),
	UINT64_C(0xe2e69915b3fff9f9),
	UINT64_C(0xb58547448ffffb2d),
	UINT64_C(0x91376c36d99995be),
	UINT64_C(0xe858ad248f5c22c9),
	UINT64_C(0xb9e08a83a5e34f07),
	UINT64_C(0x94b3a202eb1c3f39),
	UINT64_C(0xedec366b11c6cb8f),
	UINT64_C(0xbe5691ef416bd60c),
	UINT64_C(0x9845418c345644d6),
	UINT64_C(0xf3a20279ed56d48a),
	UINT64_C(0xc2e801fb244576d5),
	UINT64_C(0x9becce62836ac577),
	UINT64_C(0xf97ae3d0d2446f25),
	UINT64_C(0xc795830d75038c1d),
	UINT64_C(0x9faacf3df73609b1),
	UINT64_C(0xff77b1fcbebcdc4f),
	UINT64_C(0xcc5fc196fefd7d0c),
	UINT64_C(0xa37fce126597973c),
	UINT64_C(0x82cca4db847945ca),
	UINT64_C(0xd1476e2c07286faa),
	UINT64_C(0xa76c582338ed2621),
	UINT64_C(0x85f0468293f0eb4e),
	UINT64_C(0xd64d3d9db981787d),
	UINT64_C(0xab70fe17c79ac6ca),
	UINT64_C(0x892731ac9faf056e),
	UINT64_C(0xdb71e91432b1a24a),
	UINT64_C(0xaf8e5410288e1b6f),
	UINT64_C(0x8c71dcd9ba0b4925),
	UINT64_C(0xe0b62e2929aba83c),
	UINT64_C(0xb3c4f1ba87bc8696),
	UINT64_C(0x8fd0c16206306bab),
	UINT64_C(0xe61acf033d1a45df),
	UINT64_C(0xb8157268fdae9e4c),
	UINT64_C(0x93445b8731587ea3),
	UINT64_C(0xeba09271e88d976b),
	UINT64_C(0xbc807527ed3e12bc),
	UINT64_C(0x96cd2a865764dbca),
	UINT64_C(0xf148440a256e2c76),
	UINT64_C(0xc1069cd4eabe89f8),
	UINT64_C(0x9a6bb0aa55653b2d),
	UINT64_C(0xf712b443bbd52b7b),
	UINT64_C(0xc5a890362fddbc62),
	UINT64_C(0x9e20735e8cb16382),
	UINT64_C(0xfd00b897478238d0),
	UINT64_C(0xca66fa129f9b60a6),
	UINT64_C(0xa1ebfb4219491a1f),
	UINT64_C(0x818995ce7aa0e1b2),
	UINT64_C(0xcf42894a5dce35ea),
	UINT64_C(0xa5ced43b7e3e9188),
	UINT64_C(0x84a57695fe98746d),
	UINT64_C(0xd43bf0effdc0ba48),
	UINT64_C(0xa9c98d8ccb009506),
	UINT64_C(0x87d4713d6f33aa6b),
	UINT64_C(0xd953e8624b85dd78),
	UINT64_C(0xaddcb9e83c6b1793),
	UINT64_C(0x8b16fb203055ac76),
	UINT64_C(0xde8b2b66b3bc4723),
	UINT64_C(0xb208ef855c969f4f),
	UINT64_C(0x8e6d8c6ab0787f72),
	UINT64_C(0xe3e27a444d8d98b7),
	UINT64_C(0xb64ec836a47146f9),
	UINT64_C(0x91d8a02bb6c10594),
	UINT64_C(0xe95a99df8ace6f53),
	UINT64_C(0xbaaee17fa23ebf76),
	UINT64_C(0x9558b4661b6565f8),
	UINT64_C(0xeef453d6923bd65a),
};

#else

#define JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE_BITS 3
#define JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE (1 << JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE_BITS)

static const uint32_t JsopSmallPowersOfFive[] = {
	UINT32_C(1),	//5e0 at: 0
	UINT32_C(5),	//5e1 at: 1
	UINT32_C(25),	//5e2 at: 2
	UINT32_C(125),	//5e3 at: 3
	UINT32_C(625),	//5e4 at: 4
	UINT32_C(3125),	//5e5 at: 5
	UINT32_C(15625),	//5e6 at: 6
	UINT32_C(78125),	//5e7 at: 7
	//The following entries are used when the exponent is small and there is no need
	//for full multi-precision arithmetic
	UINT32_C(390625),	//5e8 at: 8
	UINT32_C(1953125),	//5e9 at: 9
	UINT32_C(9765625),	//5e10 at: 10
	UINT32_C(48828125),	//5e11 at: 11
	UINT32_C(244140625),	//5e12 at: 12
	UINT32_C(1220703125),	//5e13 at: 13
};

static const uint32_t JsopLargePowersOfFive[] = {
	UINT32_C(390625),	//5e8 at: 0
	UINT32_C(2264035265),	//5e16 at: 1
	UINT32_C(35),
	UINT32_C(3469536673),	//5e24 at: 3
	UINT32_C(13877787),
	UINT32_C(2242703233),	//5e32 at: 5
	UINT32_C(762134875),
	UINT32_C(1262),
	UINT32_C(2881090913),	//5e40 at: 8
	UINT32_C(3277628607),
	UINT32_C(493038065),
	UINT32_C(2972417857),	//5e48 at: 11
	UINT32_C(2513868400),
	UINT32_C(2365918787),
	UINT32_C(44841),
	UINT32_C(3561557281),	//5e56 at: 15
	UINT32_C(4291266675),
	UINT32_C(258614525),
	UINT32_C(336361620),
	UINT32_C(4),
	UINT32_C(3211403009),	//5e64 at: 20
	UINT32_C(1849224548),
	UINT32_C(3668416493),
	UINT32_C(3913284084),
	UINT32_C(1593091),
	UINT32_C(1727411425),	//5e72 at: 25
	UINT32_C(4264676815),
	UINT32_C(2304108870),
	UINT32_C(490359484),
	UINT32_C(3826237162),
	UINT32_C(144),
	UINT32_C(660917953),	//5e80 at: 31
	UINT32_C(415916962),
	UINT32_C(2066083748),
	UINT32_C(4017147345),
	UINT32_C(1042246623),
	UINT32_C(56597994),
	UINT32_C(591228065),	//5e88 at: 37
	UINT32_C(1835435568),
	UINT32_C(954476263),
	UINT32_C(1815463862),
	UINT32_C(3342519596),
	UINT32_C(2394828529),
	UINT32_C(5147),
	UINT32_C(3776417409),	//5e96 at: 44
	UINT32_C(3833115195),
	UINT32_C(474402842),
	UINT32_C(2046101519),
	UINT32_C(1659368615),
	UINT32_C(1657637457),
	UINT32_C(2010764683),
	UINT32_C(698004577),	//5e104 at: 51
	UINT32_C(3419626114),
	UINT32_C(2951551653),
	UINT32_C(3646822585),
	UINT32_C(2991042738),
	UINT32_C(1067279287),
	UINT32_C(4220257044),
	UINT32_C(182877),
	UINT32_C(629038657),	//5e112 at: 59
	UINT32_C(787213885),
	UINT32_C(253891306),
	UINT32_C(2499665971),
	UINT32_C(3231430158),
	UINT32_C(2086268280),
	UINT32_C(610685888),
	UINT32_C(2717235219),
	UINT32_C(16),
	UINT32_C(3146386465),	//5e120 at: 68
	UINT32_C(2945360919),
	UINT32_C(1201645910),
	UINT32_C(1269970438),
	UINT32_C(3697270877),
	UINT32_C(4272556672),
	UINT32_C(2396602608),
	UINT32_C(444649640),
	UINT32_C(6497131),
	UINT32_C(781532673),	//5e128 at: 77
	UINT32_C(64985353),
	UINT32_C(253049085),
	UINT32_C(594863151),
	UINT32_C(3553621484),
	UINT32_C(3288652808),
	UINT32_C(3167596762),
	UINT32_C(2788392729),
	UINT32_C(3911132675),
	UINT32_C(590),
	UINT32_C(4219958241),	//5e136 at: 87
	UINT32_C(1646867344),
	UINT32_C(2921483891),
	UINT32_C(2097734197),
	UINT32_C(4257141698),
	UINT32_C(990247303),
	UINT32_C(1062183415),
	UINT32_C(3613853524),
	UINT32_C(1909728837),
	UINT32_C(230824465),
	UINT32_C(4149751233),	//5e144 at: 97
	UINT32_C(3060071626),
	UINT32_C(1769753384),
	UINT32_C(3495466880),
	UINT32_C(3358437573),
	UINT32_C(2008509207),
	UINT32_C(80944357),
	UINT32_C(271994417),
	UINT32_C(3547574155),
	UINT32_C(1558369385),
	UINT32_C(20993),
	UINT32_C(2903436193),	//5e152 at: 108
	UINT32_C(3836166611),
	UINT32_C(569873743),
	UINT32_C(3697089598),
	UINT32_C(506642427),
	UINT32_C(3643394911),
	UINT32_C(3635369941),
	UINT32_C(3213146834),
	UINT32_C(4251234508),
	UINT32_C(3736541602),
	UINT32_C(3905565061),
	UINT32_C(1),
	UINT32_C(4223872385),	//5e160 at: 120
	UINT32_C(1378013428),
	UINT32_C(3071223888),
	UINT32_C(1460925171),
	UINT32_C(3695318035),
	UINT32_C(3594083709),
	UINT32_C(4166588825),
	UINT32_C(9582620),
	UINT32_C(2259883222),
	UINT32_C(2057664441),
	UINT32_C(314048097),
	UINT32_C(745834),
	UINT32_C(4103893857),	//5e168 at: 132
	UINT32_C(2539456274),
	UINT32_C(796452833),
	UINT32_C(1590581681),
	UINT32_C(933943993),
	UINT32_C(39447732),
	UINT32_C(198240601),
	UINT32_C(2294801633),
	UINT32_C(780411261),
	UINT32_C(2107795832),
	UINT32_C(2182169416),
	UINT32_C(3578625980),
	UINT32_C(67),
	UINT32_C(4174527809),	//5e176 at: 145
	UINT32_C(870785744),
	UINT32_C(4137068531),
	UINT32_C(2410239109),
	UINT32_C(3055320751),
	UINT32_C(3222706689),
	UINT32_C(3769389628),
	UINT32_C(4263560494),
	UINT32_C(4255268643),
	UINT32_C(3926368185),
	UINT32_C(653981470),
	UINT32_C(587937663),
	UINT32_C(26497349),
	UINT32_C(397151009),	//5e184 at: 158
	UINT32_C(2156688359),
	UINT32_C(820338928),
	UINT32_C(4166340525),
	UINT32_C(3451333400),
	UINT32_C(2001309016),
	UINT32_C(4250413995),
	UINT32_C(2439876245),
	UINT32_C(1840965499),
	UINT32_C(456283743),
	UINT32_C(1152277067),
	UINT32_C(2658417142),
	UINT32_C(3950790533),
	UINT32_C(2409),
	UINT32_C(2894159105),	//5e192 at: 172
	UINT32_C(2850127391),
	UINT32_C(1678958885),
	UINT32_C(1990048638),
	UINT32_C(4055408710),
	UINT32_C(4272372864),
	UINT32_C(3869429580),
	UINT32_C(1940770817),
	UINT32_C(3594030316),
	UINT32_C(3284427401),
	UINT32_C(4246652165),
	UINT32_C(2708404372),
	UINT32_C(1313461594),
	UINT32_C(941374947),
	UINT32_C(1018802913),	//5e200 at: 186
	UINT32_C(2474805365),
	UINT32_C(1808613142),
	UINT32_C(3733566522),
	UINT32_C(1174969991),
	UINT32_C(208162117),
	UINT32_C(2449333158),
	UINT32_C(333390995),
	UINT32_C(657484012),
	UINT32_C(4003050564),
	UINT32_C(3283517761),
	UINT32_C(4049076938),
	UINT32_C(2732157009),
	UINT32_C(2373809701),
	UINT32_C(85617),
	UINT32_C(2513210561),	//5e208 at: 201
	UINT32_C(1016877512),
	UINT32_C(1748365200),
	UINT32_C(3852954502),
	UINT32_C(3857888788),
	UINT32_C(1006212115),
	UINT32_C(2375169242),
	UINT32_C(3154262624),
	UINT32_C(3532818909),
	UINT32_C(1408331097),
	UINT32_C(862281036),
	UINT32_C(1727812628),
	UINT32_C(998560438),
	UINT32_C(3155364397),
	UINT32_C(3379585449),
	UINT32_C(7),
	UINT32_C(725707425),	//5e216 at: 217
	UINT32_C(2022950311),
	UINT32_C(3816670932),
	UINT32_C(732769258),
	UINT32_C(4043080812),
	UINT32_C(1970646603),
	UINT32_C(1649965844),
	UINT32_C(2209774132),
	UINT32_C(34671835),
	UINT32_C(4154011477),
	UINT32_C(14594082),
	UINT32_C(2762095596),
	UINT32_C(2331362765),
	UINT32_C(3092997455),
	UINT32_C(2173563787),
	UINT32_C(3041746),
	UINT32_C(3031420033),	//5e224 at: 233
	UINT32_C(1112378521),
	UINT32_C(855339782),
	UINT32_C(4191278750),
	UINT32_C(248038208),
	UINT32_C(1136169807),
	UINT32_C(2230652081),
	UINT32_C(3378214371),
	UINT32_C(1653863564),
	UINT32_C(613940998),
	UINT32_C(1392057263),
	UINT32_C(562793371),
	UINT32_C(894754680),
	UINT32_C(2060902835),
	UINT32_C(2039635717),
	UINT32_C(2771255238),
	UINT32_C(276),
	UINT32_C(197079649),	//5e232 at: 250
	UINT32_C(1018705011),
	UINT32_C(3006554488),
	UINT32_C(2498365118),
	UINT32_C(4053118026),
	UINT32_C(180317069),
	UINT32_C(2684100663),
	UINT32_C(3467047935),
	UINT32_C(64265018),
	UINT32_C(2613587416),
	UINT32_C(3738937836),
	UINT32_C(3259627721),
	UINT32_C(1993279593),
	UINT32_C(89975604),
	UINT32_C(3383830675),
	UINT32_C(840376229),
	UINT32_C(108064544),
	UINT32_C(1244077121),	//5e240 at: 267
	UINT32_C(2924965399),
	UINT32_C(2309680226),
	UINT32_C(4225625890),
	UINT32_C(4024743586),
	UINT32_C(3186759649),
	UINT32_C(2290103142),
	UINT32_C(742274996),
	UINT32_C(3734093752),
	UINT32_C(1678252460),
	UINT32_C(1783551220),
	UINT32_C(1779316223),
	UINT32_C(3105122134),
	UINT32_C(1003110619),
	UINT32_C(2607314986),
	UINT32_C(3319360306),
	UINT32_C(1773991343),
	UINT32_C(9828),
	UINT32_C(665782817),	//5e248 at: 285
	UINT32_C(229146419),
	UINT32_C(828480330),
	UINT32_C(1872227186),
	UINT32_C(1274899360),
	UINT32_C(436987809),
	UINT32_C(2866820816),
	UINT32_C(2223335119),
	UINT32_C(3643646061),
	UINT32_C(739334857),
	UINT32_C(165479088),
	UINT32_C(3727161796),
	UINT32_C(914659513),
	UINT32_C(1629480612),
	UINT32_C(3936695114),
	UINT32_C(262909759),
	UINT32_C(2460222741),
	UINT32_C(3839223843),
	UINT32_C(2553183233),	//5e256 at: 303
	UINT32_C(3201533787),
	UINT32_C(3638140786),
	UINT32_C(303378311),
	UINT32_C(1809731782),
	UINT32_C(3477761648),
	UINT32_C(3583367183),
	UINT32_C(649228654),
	UINT32_C(2915460784),
	UINT32_C(487929380),
	UINT32_C(1011012442),
	UINT32_C(1677677582),
	UINT32_C(3428152256),
	UINT32_C(1710878487),
	UINT32_C(1438394610),
	UINT32_C(2161952759),
	UINT32_C(4100910556),
	UINT32_C(1608314830),
	UINT32_C(349175),
	UINT32_C(2844586465),	//5e264 at: 322
	UINT32_C(3443431693),
	UINT32_C(4196118171),
	UINT32_C(415434029),
	UINT32_C(630253518),
	UINT32_C(2488189794),
	UINT32_C(1489572795),
	UINT32_C(9367743),
	UINT32_C(2635568983),
	UINT32_C(3945600363),
	UINT32_C(197366130),
	UINT32_C(3810635133),
	UINT32_C(2711867335),
	UINT32_C(2113136675),
	UINT32_C(978056837),
	UINT32_C(1967137308),
	UINT32_C(2758908528),
	UINT32_C(1639619325),
	UINT32_C(3252644474),
	UINT32_C(31),
	UINT32_C(2713840577),	//5e272 at: 342
	UINT32_C(1237510150),
	UINT32_C(3111818389),
	UINT32_C(2168614991),
	UINT32_C(960132517),
	UINT32_C(2334221067),
	UINT32_C(3678847574),
	UINT32_C(4257575954),
	UINT32_C(2588232138),
	UINT32_C(1127866978),
	UINT32_C(1481926900),
	UINT32_C(1058234875),
	UINT32_C(3854260918),
	UINT32_C(2839234869),
	UINT32_C(3226264225),
	UINT32_C(412099093),
	UINT32_C(1155049294),
	UINT32_C(2185964934),
	UINT32_C(1252498876),
	UINT32_C(12405201),
	UINT32_C(1557457313),	//5e280 at: 362
	UINT32_C(3833425772),
	UINT32_C(1004136347),
	UINT32_C(1651483129),
	UINT32_C(2335461751),
	UINT32_C(727312582),
	UINT32_C(1021204702),
	UINT32_C(1191139535),
	UINT32_C(1467749666),
	UINT32_C(3883227560),
	UINT32_C(2003260198),
	UINT32_C(3870778135),
	UINT32_C(4245315563),
	UINT32_C(3896076771),
	UINT32_C(94385459),
	UINT32_C(834242472),
	UINT32_C(521094134),
	UINT32_C(1514396449),
	UINT32_C(469079768),
	UINT32_C(1058644651),
	UINT32_C(1128),
	UINT32_C(3940379521),	//5e288 at: 383
	UINT32_C(184513341),
	UINT32_C(2872588323),
	UINT32_C(2214530454),
	UINT32_C(38258512),
	UINT32_C(2980860351),
	UINT32_C(114267010),
	UINT32_C(2188874685),
	UINT32_C(234079247),
	UINT32_C(2101059099),
	UINT32_C(1948702207),
	UINT32_C(947446250),
	UINT32_C(864457656),
	UINT32_C(507589568),
	UINT32_C(1321007357),
	UINT32_C(3911984176),
	UINT32_C(1011110295),
	UINT32_C(2382358050),
	UINT32_C(2389730781),
	UINT32_C(730678769),
	UINT32_C(440721283),
	UINT32_C(1845686625),	//5e296 at: 404
	UINT32_C(1677992324),
	UINT32_C(1657935696),
	UINT32_C(1595767650),
	UINT32_C(2540228626),
	UINT32_C(2875896182),
	UINT32_C(2250912325),
	UINT32_C(4264420021),
	UINT32_C(1647293907),
	UINT32_C(909975524),
	UINT32_C(1861028497),
	UINT32_C(3154654459),
	UINT32_C(4148182353),
	UINT32_C(9858781),
	UINT32_C(3948063666),
	UINT32_C(3814691712),
	UINT32_C(4061767303),
	UINT32_C(869479705),
	UINT32_C(3214562975),
	UINT32_C(3637669585),
	UINT32_C(1577112761),
	UINT32_C(40083),
	UINT32_C(947714881),	//5e304 at: 426
	UINT32_C(2202753212),
	UINT32_C(1602773364),
	UINT32_C(954894374),
	UINT32_C(1922846912),
	UINT32_C(1005415726),
	UINT32_C(1217344862),
	UINT32_C(3185023428),
	UINT32_C(2182523001),
	UINT32_C(3400828064),
	UINT32_C(2387169722),
	UINT32_C(651451590),
	UINT32_C(4240296435),
	UINT32_C(2796008183),
	UINT32_C(1282688242),
	UINT32_C(816815650),
	UINT32_C(2509429479),
	UINT32_C(3086301952),
	UINT32_C(3433595301),
	UINT32_C(521855163),
	UINT32_C(2448560117),
	UINT32_C(2772663424),
	UINT32_C(3),
	UINT32_C(714279201),	//5e312 at: 449
	UINT32_C(1020410350),
	UINT32_C(1667807623),
	UINT32_C(590233809),
	UINT32_C(3899395071),
	UINT32_C(118662799),
	UINT32_C(3737666256),
	UINT32_C(830237120),
	UINT32_C(1334266597),
	UINT32_C(2193143811),
	UINT32_C(3528363697),
	UINT32_C(760240157),
	UINT32_C(3067344132),
	UINT32_C(1988333707),
	UINT32_C(3505001481),
	UINT32_C(4082912661),
	UINT32_C(1209375287),
	UINT32_C(2265142919),
	UINT32_C(2892637054),
	UINT32_C(1935556406),
	UINT32_C(1053767867),
	UINT32_C(1157255783),
	UINT32_C(1424047),
	UINT32_C(1352440577),	//5e320 at: 472
	UINT32_C(3353128433),
	UINT32_C(943566124),
	UINT32_C(1942375735),
	UINT32_C(3933038544),
	UINT32_C(1369155590),
	UINT32_C(3288593144),
	UINT32_C(2689786274),
	UINT32_C(3608159034),
	UINT32_C(1149596585),
	UINT32_C(3474119098),
	UINT32_C(1887901699),
	UINT32_C(1390164635),
	UINT32_C(3853669096),
	UINT32_C(119012174),
	UINT32_C(3192759855),
	UINT32_C(179034081),
	UINT32_C(2355293519),
	UINT32_C(3468291195),
	UINT32_C(3563470881),
	UINT32_C(2702541568),
	UINT32_C(3437458918),
	UINT32_C(2217683442),
	UINT32_C(129),
	UINT32_C(3238080737),	//5e328 at: 496
	UINT32_C(1092838988),
	UINT32_C(3604018929),
	UINT32_C(188993423),
	UINT32_C(3314876386),
	UINT32_C(4190101649),
	UINT32_C(3453602403),
	UINT32_C(2734090681),
	UINT32_C(655045524),
	UINT32_C(860710505),
	UINT32_C(1251210981),
	UINT32_C(2831862756),
	UINT32_C(3165616114),
	UINT32_C(698143690),
	UINT32_C(404807335),
	UINT32_C(3509925015),
	UINT32_C(235700236),
	UINT32_C(2996464906),
	UINT32_C(1059378143),
	UINT32_C(3387408944),
	UINT32_C(3108771071),
	UINT32_C(289504584),
	UINT32_C(576142573),
	UINT32_C(50592322),
	UINT32_C(3124251329),	//5e336 at: 520
	UINT32_C(545530673),
	UINT32_C(2629055250),
	UINT32_C(3658303510),
	UINT32_C(1078096582),
	UINT32_C(2255011359),
	UINT32_C(1326477474),
	UINT32_C(424887184),
	UINT32_C(186434668),
	UINT32_C(706177025),
	UINT32_C(4191115790),
	UINT32_C(1792287720),
	UINT32_C(465630150),
	UINT32_C(3430734641),
	UINT32_C(54361038),
	UINT32_C(3523955592),
	UINT32_C(3486049669),
	UINT32_C(3846617990),
	UINT32_C(3783379597),
	UINT32_C(209392781),
	UINT32_C(351679122),
	UINT32_C(1239504061),
	UINT32_C(3701261351),
	UINT32_C(1481304753),
	UINT32_C(4601),
};

static const uint16_t JsopLargePowersOfFiveOffsets[] = {
	0,
	1,
	3,
	5,
	8,
	11,
	15,
	20,
	25,
	31,
	37,
	44,
	51,
	59,
	68,
	77,
	87,
	97,
	108,
	120,
	132,
	145,
	158,
	172,
	186,
	201,
	217,
	233,
	250,
	267,
	285,
	303,
	322,
	342,
	362,
	383,
	404,
	426,
	449,
	472,
	496,
	520,
	545,
};

static const uint32_t JsopNormalizedReciprocalsOf5[] = {
	UINT32_C(0xcccccccc), UINT32_C(0xcccccccc),
	UINT32_C(0x70a3d70a), UINT32_C(0xa3d70a3d),
	UINT32_C(0x8d4fdf3b), UINT32_C(0x83126e97),
	UINT32_C(0xe219652b), UINT32_C(0xd1b71758),
	UINT32_C(0x1b478423), UINT32_C(0xa7c5ac47),
	UINT32_C(0xaf6c69b5), UINT32_C(0x8637bd05),
	UINT32_C(0xe57a42bc), UINT32_C(0xd6bf94d5),
	UINT32_C(0x8461cefc), UINT32_C(0xabcc7711),
	UINT32_C(0x36b4a597), UINT32_C(0x89705f41),
	UINT32_C(0xbdedd5be), UINT32_C(0xdbe6fece),
	UINT32_C(0xcb24aafe), UINT32_C(0xafebff0b),
	UINT32_C(0x6f5088cb), UINT32_C(0x8cbccc09),
	UINT32_C(0x4bb40e13), UINT32_C(0xe12e1342),
	UINT32_C(0x095cd80f), UINT32_C(0xb424dc35),
	UINT32_C(0x3ab0acd9), UINT32_C(0x901d7cf7),
	UINT32_C(0xc44de15b), UINT32_C(0xe69594be),
	UINT32_C(0x36a4b449), UINT32_C(0xb877aa32),
	UINT32_C(0x921d5d07), UINT32_C(0x9392ee8e),
	UINT32_C(0xb69561a5), UINT32_C(0xec1e4a7d),
	UINT32_C(0x92111aea), UINT32_C(0xbce50864),
	UINT32_C(0x74da7bee), UINT32_C(0x971da050),
	UINT32_C(0xbaf72cb1), UINT32_C(0xf1c90080),
	UINT32_C(0x95928a27), UINT32_C(0xc16d9a00),
	UINT32_C(0x44753b52), UINT32_C(0x9abe14cd),
	UINT32_C(0xd3eec551), UINT32_C(0xf79687ae),
	UINT32_C(0x76589dda), UINT32_C(0xc6120625),
	UINT32_C(0x91e07e48), UINT32_C(0x9e74d1b7),
	UINT32_C(0x8300ca0d), UINT32_C(0xfd87b5f2),
	UINT32_C(0x359a3b3e), UINT32_C(0xcad2f7f5),
	UINT32_C(0x5e14fc31), UINT32_C(0xa2425ff7),
	UINT32_C(0x4b43fcf4), UINT32_C(0x81ceb32c),
	UINT32_C(0x453994ba), UINT32_C(0xcfb11ead),
	UINT32_C(0xd0fadd61), UINT32_C(0xa6274bbd),
	UINT32_C(0xda624ab4), UINT32_C(0x84ec3c97),
	UINT32_C(0xc3d07787), UINT32_C(0xd4ad2dbf),
	UINT32_C(0x697392d2), UINT32_C(0xaa242499),
	UINT32_C(0x545c7575), UINT32_C(0x881cea14),
	UINT32_C(0x53c72255), UINT32_C(0xd9c7dced),
	UINT32_C(0xa96c1b77), UINT32_C(0xae397d8a),
	UINT32_C(0xbabce2c6), UINT32_C(0x8b61313b),
	UINT32_C(0x912e37a3), UINT32_C(0xdf01e85f),
	UINT32_C(0x40f1c61c), UINT32_C(0xb267ed19),
	UINT32_C(0x9a5b04e3), UINT32_C(0x8eb98a7a),
	UINT32_C(0x2a2b3b05), UINT32_C(0xe45c10c4),
	UINT32_C(0xbb55c8d1), UINT32_C(0xb6b00d69),
	UINT32_C(0x62ab070d), UINT32_C(0x92267121),
	UINT32_C(0x9dde71af), UINT32_C(0xe9d71b68),
	UINT32_C(0xb17ec159), UINT32_C(0xbb127c53),
	UINT32_C(0x27989aad), UINT32_C(0x95a86376),
	UINT32_C(0xa5c0f77c), UINT32_C(0xef73d256),
	UINT32_C(0x849a5f96), UINT32_C(0xbf8fdb78),
	UINT32_C(0xd07b7fab), UINT32_C(0x993fe2c6),
	UINT32_C(0x4d9265df), UINT32_C(0xf5330471),
	UINT32_C(0xa4751e4c), UINT32_C(0xc428d05a),
	UINT32_C(0xb6c4183d), UINT32_C(0x9ced737b),
	UINT32_C(0xbe068d2e), UINT32_C(0xfb158592),
	UINT32_C(0x64d20a8b), UINT32_C(0xc8de0475),
	UINT32_C(0xb70e6ed6), UINT32_C(0xa0b19d2a),
	UINT32_C(0x5f3ebf11), UINT32_C(0x808e1755),
	UINT32_C(0x653131b6), UINT32_C(0xcdb02555),
	UINT32_C(0xb75a8e2b), UINT32_C(0xa48ceaaa),
	UINT32_C(0xf9153e89), UINT32_C(0x83a3eeee),
	UINT32_C(0x8e88640e), UINT32_C(0xd29fe4b1),
	UINT32_C(0xa539e9a5), UINT32_C(0xa87fea27),
	UINT32_C(0xea94baea), UINT32_C(0x86ccbb52),
	UINT32_C(0xaa879177), UINT32_C(0xd7adf884),
	UINT32_C(0xeed2dac5), UINT32_C(0xac8b2d36),
	UINT32_C(0xbf0f156b), UINT32_C(0x8a08f0f8),
	UINT32_C(0x98182244), UINT32_C(0xdcdb1b27),
	UINT32_C(0x79ace837), UINT32_C(0xb0af48ec),
	UINT32_C(0x948a535f), UINT32_C(0x8d590723),
	UINT32_C(0x20dd5232), UINT32_C(0xe2280b6c),
	UINT32_C(0x1a4aa828), UINT32_C(0xb4ecd5f0),
	UINT32_C(0x483bb9b9), UINT32_C(0x90bd77f3),
	UINT32_C(0x7392c2c2), UINT32_C(0xe7958cb8),
	UINT32_C(0x8fa89bce), UINT32_C(0xb9447093),
	UINT32_C(0x0c86e30b), UINT32_C(0x9436c076),
	UINT32_C(0x473e3813), UINT32_C(0xed246723),
	UINT32_C(0x05cb600f), UINT32_C(0xbdb6b8e9),
	UINT32_C(0x6b0919a5), UINT32_C(0x97c560ba),
	UINT32_C(0xab41c2a2), UINT32_C(0xf2d56790),
	UINT32_C(0x229b021b), UINT32_C(0xc24452da),
	UINT32_C(0xb548ce7c), UINT32_C(0x9b69dbe1),
	UINT32_C(0x88747d94), UINT32_C(0xf8a95fcf),
	UINT32_C(0xa05d3143), UINT32_C(0xc6ede63f),
	UINT32_C(0xe6b0f436), UINT32_C(0x9f24b832),
	UINT32_C(0xd78186bc), UINT32_C(0xfea126b7),
	UINT32_C(0x79346bca), UINT32_C(0xcbb41ef9),
	UINT32_C(0xfa90563b), UINT32_C(0xa2f67f2d),
	UINT32_C(0xc873782f), UINT32_C(0x825ecc24),
	UINT32_C(0xa71f26b2), UINT32_C(0xd097ad07),
	UINT32_C(0xb8e5b88e), UINT32_C(0xa6dfbd9f),
	UINT32_C(0x2d8493a5), UINT32_C(0x857fcae6),
	UINT32_C(0x7c0752a2), UINT32_C(0xd59944a3),
	UINT32_C(0xfcd2a881), UINT32_C(0xaae103b5),
	UINT32_C(0xfd75539b), UINT32_C(0x88b402f7),
	UINT32_C(0x958885c4), UINT32_C(0xdab99e59),
	UINT32_C(0x77a06b03), UINT32_C(0xaefae514),
	UINT32_C(0xc619ef36), UINT32_C(0x8bfbea76),
	UINT32_C(0x70297ebd), UINT32_C(0xdff97724),
	UINT32_C(0xf3546564), UINT32_C(0xb32df8e9),
	UINT32_C(0xc2a9eab6), UINT32_C(0x8f57fa54),
	UINT32_C(0x9ddcaabd), UINT32_C(0xe5599087),
	UINT32_C(0x17e3bbcb), UINT32_C(0xb77ada06),
	UINT32_C(0x464fc96f), UINT32_C(0x92c8ae6b),
	UINT32_C(0xa3b2dbe5), UINT32_C(0xeadab0ab),
	UINT32_C(0xb628afea), UINT32_C(0xbbe226ef),
	UINT32_C(0x91ba2655), UINT32_C(0x964e858c),
	UINT32_C(0x82c37088), UINT32_C(0xf07da27a),
	UINT32_C(0x9bcf8d39), UINT32_C(0xc06481fb),
	UINT32_C(0x163fa42e), UINT32_C(0x99ea0196),
	UINT32_C(0xf065d37d), UINT32_C(0xf64335bc),
	UINT32_C(0xf384a931), UINT32_C(0xc5029163),
	UINT32_C(0x2936edc0), UINT32_C(0x9d9ba783),
	UINT32_C(0x41f17c67), UINT32_C(0xfc2c3f38),
	UINT32_C(0x34c13052), UINT32_C(0xc9bcff60),
	UINT32_C(0x2a3426a8), UINT32_C(0xa163ff80),
	UINT32_C(0x8829b887), UINT32_C(0x811ccc66),
	UINT32_C(0xa6a9273e), UINT32_C(0xce947a3d),
	UINT32_C(0x1eedb8fe), UINT32_C(0xa54394fe),
	UINT32_C(0x4bf160cb), UINT32_C(0x843610cb),
	UINT32_C(0x79823479), UINT32_C(0xd389b478),
	UINT32_C(0xc79b5d2d), UINT32_C(0xa93af6c6),
	UINT32_C(0x6c7c4a8b), UINT32_C(0x87625f05),
	UINT32_C(0x7a607744), UINT32_C(0xd89d64d5),
	UINT32_C(0x2eb3929d), UINT32_C(0xad4ab711),
	UINT32_C(0xbef60ee4), UINT32_C(0x8aa22c0d),
	UINT32_C(0x64bce4a0), UINT32_C(0xddd0467c),
	UINT32_C(0xb6fd83b3), UINT32_C(0xb1736b96),
	UINT32_C(0xc5979c8f), UINT32_C(0x8df5efab),
	UINT32_C(0xd5bf60e6), UINT32_C(0xe3231912),
	UINT32_C(0xaaff80b8), UINT32_C(0xb5b5ada8),
	UINT32_C(0xef32cd60), UINT32_C(0x915e2486),
	UINT32_C(0xe51e1566), UINT32_C(0xe896a0d7),
	UINT32_C(0x50e4ddeb), UINT32_C(0xba121a46),
	UINT32_C(0x40b717ef), UINT32_C(0x94db4838),
	UINT32_C(0x678b597f), UINT32_C(0xee2ba6c0),
	UINT32_C(0x86091465), UINT32_C(0xbe895233),
	UINT32_C(0x6b3a76b7), UINT32_C(0x986ddb5c),
	UINT32_C(0xdec3f126), UINT32_C(0xf3e2f893),
	UINT32_C(0xe5698db8), UINT32_C(0xc31bfa0f),
	UINT32_C(0x51213e2d), UINT32_C(0x9c1661a6),
	UINT32_C(0x1b68637b), UINT32_C(0xf9bd690a),
	UINT32_C(0x7c5382c8), UINT32_C(0xc7caba6e),
	UINT32_C(0xfd0f9bd3), UINT32_C(0x9fd561f1),
	UINT32_C(0x94e5c61f), UINT32_C(0xffbbcfe9),
	UINT32_C(0x10b7d1b3), UINT32_C(0xcc963fee),
	UINT32_C(0x0d5fdaf5), UINT32_C(0xa3ab6658),
	UINT32_C(0x3de648c4), UINT32_C(0x82ef8513),
	UINT32_C(0xfca3a7a0), UINT32_C(0xd17f3b51),
	UINT32_C(0x96e952e7), UINT32_C(0xa798fc41),
	UINT32_C(0x45877585), UINT32_C(0x8613fd01),
	UINT32_C(0xa27255a2), UINT32_C(0xd686619b),
	UINT32_C(0x81f5114f), UINT32_C(0xab9eb47c),
	UINT32_C(0xce5da772), UINT32_C(0x894bc396),
	UINT32_C(0x7d62a583), UINT32_C(0xdbac6c24),
	UINT32_C(0x644eeacf), UINT32_C(0xafbd2350),
	UINT32_C(0x83725573), UINT32_C(0x8c974f73),
	UINT32_C(0xd25088b8), UINT32_C(0xe0f218b8),
	UINT32_C(0xdb73a093), UINT32_C(0xb3f4e093),
	UINT32_C(0xe2c2e6dc), UINT32_C(0x8ff71a0f),
	UINT32_C(0x046b0afa), UINT32_C(0xe65829b3),
	UINT32_C(0x69ef3bfb), UINT32_C(0xb84687c2),
	UINT32_C(0xbb25c995), UINT32_C(0x936b9fce),
	UINT32_C(0x91d60f56), UINT32_C(0xebdf6617),
	UINT32_C(0xdb11a5de), UINT32_C(0xbcb2b812),
	UINT32_C(0x15a7b7e5), UINT32_C(0x96f5600f),
	UINT32_C(0xbc3f8ca1), UINT32_C(0xf18899b1),
	UINT32_C(0x3032d6e7), UINT32_C(0xc13a148e),
	UINT32_C(0x8cf578b9), UINT32_C(0x9a94dd3e),
	UINT32_C(0xe188c128), UINT32_C(0xf7549530),
	UINT32_C(0x1ad3cdba), UINT32_C(0xc5dd4427),
	UINT32_C(0x15763e2e), UINT32_C(0x9e4a9cec),
	UINT32_C(0x88bd304a), UINT32_C(0xfd442e46),
	UINT32_C(0x06fdc03b), UINT32_C(0xca9cf1d2),
	UINT32_C(0x38cb002f), UINT32_C(0xa21727db),
	UINT32_C(0x93d599bf), UINT32_C(0x81ac1fe2),
	UINT32_C(0xb955c2cc), UINT32_C(0xcf79cc9d),
	UINT32_C(0xc777cf09), UINT32_C(0xa5fb0a17),
	UINT32_C(0xd2c63f3b), UINT32_C(0x84c8d4df),
	UINT32_C(0x8470652b), UINT32_C(0xd47487cc),
	UINT32_C(0x038d1dbc), UINT32_C(0xa9f6d30a),
	UINT32_C(0xcfa417c9), UINT32_C(0x87f8a8d4),
	UINT32_C(0x19068c76), UINT32_C(0xd98ddaee),
	UINT32_C(0x4738705e), UINT32_C(0xae0b158b),
	UINT32_C(0x38f9f37e), UINT32_C(0x8b3c113c),
	UINT32_C(0xf4c31f31), UINT32_C(0xdec681f9),
	UINT32_C(0x2a35b28d), UINT32_C(0xb23867fb),
	UINT32_C(0x882af53e), UINT32_C(0x8e938662),
	UINT32_C(0x7377eeca), UINT32_C(0xe41f3d6a),
	UINT32_C(0x292cbf08), UINT32_C(0xb67f6455),
	UINT32_C(0x5423cc06), UINT32_C(0x91ff8377),
	UINT32_C(0x869facd7), UINT32_C(0xe998d258),
	UINT32_C(0xd2195712), UINT32_C(0xbae0a846),
	UINT32_C(0x0e7aac0e), UINT32_C(0x9580869f),
	UINT32_C(0x172aace4), UINT32_C(0xef340a98),
	UINT32_C(0x78eef0b6), UINT32_C(0xbf5cd546),
	UINT32_C(0x2d8bf3c5), UINT32_C(0x99171105),
	UINT32_C(0x15acb93b), UINT32_C(0xf4f1b4d5),
	UINT32_C(0x77bd60fc), UINT32_C(0xc3f490aa),
	UINT32_C(0xc6311a63), UINT32_C(0x9cc3a6ee),
	UINT32_C(0x3d1b5d6c), UINT32_C(0xfad2a4b1),
	UINT32_C(0xfdaf7df0), UINT32_C(0xc8a883c0),
	UINT32_C(0x97bf97f3), UINT32_C(0xa086cfcd),
	UINT32_C(0x4632dff6), UINT32_C(0x806bd971),
	UINT32_C(0x70516656), UINT32_C(0xcd795be8),
	UINT32_C(0x8d0deb78), UINT32_C(0xa4611653),
	UINT32_C(0x3da4bc60), UINT32_C(0x8380dea9),
	UINT32_C(0x62a12d66), UINT32_C(0xd267caa8),
	UINT32_C(0xb54dbdeb), UINT32_C(0xa8530886),
	UINT32_C(0xf77164bc), UINT32_C(0x86a8d39e),
	UINT32_C(0x25823ac7), UINT32_C(0xd77485cb),
	UINT32_C(0xb79b6239), UINT32_C(0xac5d37d5),
	UINT32_C(0xf9491b60), UINT32_C(0x89e42caa),
	UINT32_C(0xf541c567), UINT32_C(0xdca04777),
	UINT32_C(0xc4349dec), UINT32_C(0xb080392c),
	UINT32_C(0x9cf6e4bd), UINT32_C(0x8d3360f0),
	UINT32_C(0xc7f16dfb), UINT32_C(0xe1ebce4d),
	UINT32_C(0x065abe63), UINT32_C(0xb4bca50b),
	UINT32_C(0x3848984f), UINT32_C(0x9096ea6f),
	UINT32_C(0xc07426e5), UINT32_C(0xe757dd7e),
	UINT32_C(0x99f68584), UINT32_C(0xb9131798),
	UINT32_C(0xae5ed136), UINT32_C(0x940f4613),
	UINT32_C(0x4a314ebd), UINT32_C(0xece53cec),
	UINT32_C(0x08277231), UINT32_C(0xbd8430bd),
	UINT32_C(0x6cec5b5a), UINT32_C(0x979cf3ca),
	UINT32_C(0xe17a2bc4), UINT32_C(0xf294b943),
	UINT32_C(0x4dfb5636), UINT32_C(0xc2109436),
	UINT32_C(0xd7fc44f8), UINT32_C(0x9b407691),
	UINT32_C(0x8cc6d4c0), UINT32_C(0xf867241c),
	UINT32_C(0x709f109a), UINT32_C(0xc6b8e9b0),
	UINT32_C(0x26e5a6e1), UINT32_C(0x9efa548d),
	UINT32_C(0x0b090b02), UINT32_C(0xfe5d5415),
	UINT32_C(0xa26da268), UINT32_C(0xcb7ddcdd),
	UINT32_C(0xb52481ed), UINT32_C(0xa2cb1717),
	UINT32_C(0x5db6ce57), UINT32_C(0x823c1279),
	UINT32_C(0xfc57b08b), UINT32_C(0xd0601d8e),
	UINT32_C(0xc9dfc06f), UINT32_C(0xa6b34ad8),
	UINT32_C(0xa17fcd26), UINT32_C(0x855c3be0),
	UINT32_C(0xcf32e1d6), UINT32_C(0xd5605fcd),
	UINT32_C(0xd8f58178), UINT32_C(0xaab37fd7),
	UINT32_C(0x7a5e012d), UINT32_C(0x888f9979),
	UINT32_C(0x90966848), UINT32_C(0xda7f5bf5),
	UINT32_C(0x4078536d), UINT32_C(0xaecc4991),
	UINT32_C(0x006042bd), UINT32_C(0x8bd6a141),
	UINT32_C(0x67006ac9), UINT32_C(0xdfbdcece),
	UINT32_C(0x8599ef07), UINT32_C(0xb2fe3f0b),
	UINT32_C(0x37ae58d2), UINT32_C(0x8f31cc09),
	UINT32_C(0x5916f484), UINT32_C(0xe51c79a8),
	UINT32_C(0x14125d36), UINT32_C(0xb749faed),
	UINT32_C(0x7675175f), UINT32_C(0x92a1958a),
	UINT32_C(0x23ee8bcb), UINT32_C(0xea9c2277),
	UINT32_C(0x83253ca2), UINT32_C(0xbbb01b92),
	UINT32_C(0x35b763b5), UINT32_C(0x96267c75),
	UINT32_C(0xbc589f88), UINT32_C(0xf03d93ee),
	UINT32_C(0x637a1939), UINT32_C(0xc0314325),
	UINT32_C(0x4f94e0fb), UINT32_C(0x99c10284),
	UINT32_C(0x7f549b2b), UINT32_C(0xf6019da0),
	UINT32_C(0x99107c22), UINT32_C(0xc4ce17b3),
	UINT32_C(0xada6c9b5), UINT32_C(0x9d71ac8f),
	UINT32_C(0x15d7a922), UINT32_C(0xfbe91419),
	UINT32_C(0x44ac874e), UINT32_C(0xc9874347),
	UINT32_C(0x6a239f72), UINT32_C(0xa139029f),
	UINT32_C(0x881c7f8e), UINT32_C(0x80fa687f),
	UINT32_C(0x402d98e3), UINT32_C(0xce5d73ff),
	UINT32_C(0x668ae0b6), UINT32_C(0xa5178fff),
	UINT32_C(0x1ed58091), UINT32_C(0x8412d999),
	UINT32_C(0x31559a83), UINT32_C(0xd3515c28),
	UINT32_C(0x5aaae202), UINT32_C(0xa90de353),
	UINT32_C(0xe2224e68), UINT32_C(0x873e4f75),
	UINT32_C(0x369d4a40), UINT32_C(0xd863b256),
	UINT32_C(0x5ee43b66), UINT32_C(0xad1c8eab),
	UINT32_C(0x7f1cfc52), UINT32_C(0x8a7d3eef),
	UINT32_C(0x31c7fa1d), UINT32_C(0xdd95317f),
	UINT32_C(0xf49ffb4a), UINT32_C(0xb1442798),
	UINT32_C(0x907ffc3b), UINT32_C(0x8dd01fad),
	UINT32_C(0xb3fff9f9), UINT32_C(0xe2e69915),
	UINT32_C(0x8ffffb2d), UINT32_C(0xb5854744),
	UINT32_C(0xd99995be), UINT32_C(0x91376c36),
	UINT32_C(0x8f5c22c9), UINT32_C(0xe858ad24),
	UINT32_C(0xa5e34f07), UINT32_C(0xb9e08a83),
	UINT32_C(0xeb1c3f39), UINT32_C(0x94b3a202),
	UINT32_C(0x11c6cb8f), UINT32_C(0xedec366b),
	UINT32_C(0x416bd60c), UINT32_C(0xbe5691ef),
	UINT32_C(0x345644d6), UINT32_C(0x9845418c),
	UINT32_C(0xed56d48a), UINT32_C(0xf3a20279),
	UINT32_C(0x244576d5), UINT32_C(0xc2e801fb),
	UINT32_C(0x836ac577), UINT32_C(0x9becce62),
	UINT32_C(0xd2446f25), UINT32_C(0xf97ae3d0),
	UINT32_C(0x75038c1d), UINT32_C(0xc795830d),
	UINT32_C(0xf73609b1), UINT32_C(0x9faacf3d),
	UINT32_C(0xbebcdc4f), UINT32_C(0xff77b1fc),
	UINT32_C(0xfefd7d0c), UINT32_C(0xcc5fc196),
	UINT32_C(0x6597973c), UINT32_C(0xa37fce12),
	UINT32_C(0x847945ca), UINT32_C(0x82cca4db),
	UINT32_C(0x07286faa), UINT32_C(0xd1476e2c),
	UINT32_C(0x38ed2621), UINT32_C(0xa76c5823),
	UINT32_C(0x93f0eb4e), UINT32_C(0x85f04682),
	UINT32_C(0xb981787d), UINT32_C(0xd64d3d9d),
	UINT32_C(0xc79ac6ca), UINT32_C(0xab70fe17),
	UINT32_C(0x9faf056e), UINT32_C(0x892731ac),
	UINT32_C(0x32b1a24a), UINT32_C(0xdb71e914),
	UINT32_C(0x288e1b6f), UINT32_C(0xaf8e5410),
	UINT32_C(0xba0b4925), UINT32_C(0x8c71dcd9),
	UINT32_C(0x29aba83c), UINT32_C(0xe0b62e29),
	UINT32_C(0x87bc8696), UINT32_C(0xb3c4f1ba),
	UINT32_C(0x06306bab), UINT32_C(0x8fd0c162),
	UINT32_C(0x3d1a45df), UINT32_C(0xe61acf03),
	UINT32_C(0xfdae9e4c), UINT32_C(0xb8157268),
	UINT32_C(0x31587ea3), UINT32_C(0x93445b87),
	UINT32_C(0xe88d976b), UINT32_C(0xeba09271),
	UINT32_C(0xed3e12bc), UINT32_C(0xbc807527),
	UINT32_C(0x5764dbca), UINT32_C(0x96cd2a86),
	UINT32_C(0x256e2c76), UINT32_C(0xf148440a),
	UINT32_C(0xeabe89f8), UINT32_C(0xc1069cd4),
	UINT32_C(0x55653b2d), UINT32_C(0x9a6bb0aa),
	UINT32_C(0xbbd52b7b), UINT32_C(0xf712b443),
	UINT32_C(0x2fddbc62), UINT32_C(0xc5a89036),
	UINT32_C(0x8cb16382), UINT32_C(0x9e20735e),
	UINT32_C(0x478238d0), UINT32_C(0xfd00b897),
	UINT32_C(0x9f9b60a6), UINT32_C(0xca66fa12),
	UINT32_C(0x19491a1f), UINT32_C(0xa1ebfb42),
	UINT32_C(0x7aa0e1b2), UINT32_C(0x818995ce),
	UINT32_C(0x5dce35ea), UINT32_C(0xcf42894a),
	UINT32_C(0x7e3e9188), UINT32_C(0xa5ced43b),
	UINT32_C(0xfe98746d), UINT32_C(0x84a57695),
	UINT32_C(0xfdc0ba48), UINT32_C(0xd43bf0ef),
	UINT32_C(0xcb009506), UINT32_C(0xa9c98d8c),
	UINT32_C(0x6f33aa6b), UINT32_C(0x87d4713d),
	UINT32_C(0x4b85dd78), UINT32_C(0xd953e862),
	UINT32_C(0x3c6b1793), UINT32_C(0xaddcb9e8),
	UINT32_C(0x3055ac76), UINT32_C(0x8b16fb20),
	UINT32_C(0xb3bc4723), UINT32_C(0xde8b2b66),
	UINT32_C(0x5c969f4f), UINT32_C(0xb208ef85),
	UINT32_C(0xb0787f72), UINT32_C(0x8e6d8c6a),
	UINT32_C(0x4d8d98b7), UINT32_C(0xe3e27a44),
	UINT32_C(0xa47146f9), UINT32_C(0xb64ec836),
	UINT32_C(0xb6c10594), UINT32_C(0x91d8a02b),
	UINT32_C(0x8ace6f53), UINT32_C(0xe95a99df),
	UINT32_C(0xa23ebf76), UINT32_C(0xbaaee17f),
	UINT32_C(0x1b6565f8), UINT32_C(0x9558b466),
	UINT32_C(0x923bd65a), UINT32_C(0xeef453d6),
};

#endif

static const uint16_t JsopNormalizedReciprocalExponentsOf5[] = {
	66,
	68,
	70,
	73,
	75,
	77,
	80,
	82,
	84,
	87,
	89,
	91,
	94,
	96,
	98,
	101,
	103,
	105,
	108,
	110,
	112,
	115,
	117,
	119,
	122,
	124,
	126,
	129,
	131,
	133,
	135,
	138,
	140,
	142,
	145,
	147,
	149,
	152,
	154,
	156,
	159,
	161,
	163,
	166,
	168,
	170,
	173,
	175,
	177,
	180,
	182,
	184,
	187,
	189,
	191,
	194,
	196,
	198,
	200,
	203,
	205,
	207,
	210,
	212,
	214,
	217,
	219,
	221,
	224,
	226,
	228,
	231,
	233,
	235,
	238,
	240,
	242,
	245,
	247,
	249,
	252,
	254,
	256,
	259,
	261,
	263,
	266,
	268,
	270,
	272,
	275,
	277,
	279,
	282,
	284,
	286,
	289,
	291,
	293,
	296,
	298,
	300,
	303,
	305,
	307,
	310,
	312,
	314,
	317,
	319,
	321,
	324,
	326,
	328,
	331,
	333,
	335,
	337,
	340,
	342,
	344,
	347,
	349,
	351,
	354,
	356,
	358,
	361,
	363,
	365,
	368,
	370,
	372,
	375,
	377,
	379,
	382,
	384,
	386,
	389,
	391,
	393,
	396,
	398,
	400,
	403,
	405,
	407,
	409,
	412,
	414,
	416,
	419,
	421,
	423,
	426,
	428,
	430,
	433,
	435,
	437,
	440,
	442,
	444,
	447,
	449,
	451,
	454,
	456,
	458,
	461,
	463,
	465,
	468,
	470,
	472,
	474,
	477,
	479,
	481,
	484,
	486,
	488,
	491,
	493,
	495,
	498,
	500,
	502,
	505,
	507,
	509,
	512,
	514,
	516,
	519,
	521,
	523,
	526,
	528,
	530,
	533,
	535,
	537,
	539,
	542,
	544,
	546,
	549,
	551,
	553,
	556,
	558,
	560,
	563,
	565,
	567,
	570,
	572,
	574,
	577,
	579,
	581,
	584,
	586,
	588,
	591,
	593,
	595,
	598,
	600,
	602,
	605,
	607,
	609,
	611,
	614,
	616,
	618,
	621,
	623,
	625,
	628,
	630,
	632,
	635,
	637,
	639,
	642,
	644,
	646,
	649,
	651,
	653,
	656,
	658,
	660,
	663,
	665,
	667,
	670,
	672,
	674,
	676,
	679,
	681,
	683,
	686,
	688,
	690,
	693,
	695,
	697,
	700,
	702,
	704,
	707,
	709,
	711,
	714,
	716,
	718,
	721,
	723,
	725,
	728,
	730,
	732,
	735,
	737,
	739,
	742,
	744,
	746,
	748,
	751,
	753,
	755,
	758,
	760,
	762,
	765,
	767,
	769,
	772,
	774,
	776,
	779,
	781,
	783,
	786,
	788,
	790,
	793,
	795,
	797,
	800,
	802,
	804,
	807,
	809,
	811,
	813,
	816,
	818,
	820,
	823,
	825,
	827,
	830,
	832,
	834,
	837,
	839,
	841,
	844,
	846,
	848,
	851,
	853,
	855,
	858,
};

//! Gets the size of the given array
template <typename T, size_t N>
JSOP_INLINE constexpr size_t jsop_get_array_size(const T (&a)[N]) noexcept {
	return N;
}

#if JSOP_WORD_SIZE == 64
//! Counts the number of significant bits in the given value (which cannot be zero)
JSOP_INLINE int jsop_uint_count_significant_bits(uint64_t value) noexcept {
	assert(value != 0);
#ifndef JSOP_USE_CLZ
	return __bsrq(value) + 1;
#else
	return 64 - __builtin_clzll(value);
#endif
}
#endif

//! Counts the number of significant bits in the given value (which cannot be zero)
JSOP_INLINE int jsop_uint_count_significant_bits(uint32_t value) noexcept {
	assert(value != 0);
#ifndef JSOP_USE_CLZ
	return _bit_scan_reverse(value) + 1;
#else
	return 32 - __builtin_clz(value);
#endif
}

#if JSOP_WORD_SIZE == 64
//! Unsigned multiply of the given values a and b, and returns the result as 2 unsigned integers
JSOP_INLINE void jsop_uint_multiply_1x1(uint64_t *low, uint64_t *high, uint64_t a, uint64_t b) noexcept {
	unsigned __int128 p;

	p = static_cast<unsigned __int128>(a) * b;
	*low = static_cast<uint64_t>(p);
	*high = static_cast<uint64_t>(p >> 64);
}
#endif

//! Unsigned multiply of the given values a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_multiply_1x1(uint32_t *low, uint32_t *high, uint32_t a, uint32_t b) noexcept {
	uint64_t p;

	p = static_cast<uint64_t>(a) * b;
	*low = static_cast<uint32_t>(p);
	*high = static_cast<uint32_t>(p >> 32);
}

#if JSOP_WORD_SIZE == 64
//! Unsigned addition of a double width integer a and an integer b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_add_2x1(uint64_t *low, uint64_t *high, uint64_t a_low, uint64_t a_high, uint64_t b) noexcept {
	unsigned __int128 a;

	a = (static_cast<unsigned __int128>(a_high) << 64) | a_low;
	a += b;
	*low = static_cast<uint64_t>(a);
	*high = static_cast<uint64_t>(a >> 64);
}
#endif

//! Unsigned addition of given double width integer a and integer b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_add_2x1(uint32_t *low, uint32_t *high, uint32_t a_low, uint32_t a_high, uint32_t b) noexcept {
	uint64_t a;

	a = (static_cast<uint64_t>(a_high) << 32) | a_low;
	a += b;
	*low = static_cast<uint32_t>(a);
	*high = static_cast<uint32_t>(a >> 32);
}

#if JSOP_WORD_SIZE == 64
//! Unsigned subtraction of the given integers a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_subtract_1x1(uint64_t *low, uint64_t *high, uint64_t a, uint64_t b) noexcept {
	unsigned __int128 d;

	d = static_cast<unsigned __int128>(a) - b;
	*low = static_cast<uint64_t>(d);
	*high = static_cast<uint64_t>(d >> 64);
}
#endif

//! Unsigned subtraction of the given integers a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_subtract_1x1(uint32_t *low, uint32_t *high, uint32_t a, uint32_t b) noexcept {
	uint64_t d;

	d = static_cast<uint64_t>(a) - b;
	*low = static_cast<uint32_t>(d);
	*high = static_cast<uint32_t>(d >> 32);
}

#if JSOP_WORD_SIZE == 64
//! Unsigned subtraction with borrow of the given integers a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_subtract_with_borrow_1x1(uint64_t *low, uint64_t *high, uint64_t a, uint64_t b, uint64_t borrow) noexcept {
	unsigned __int128 d;

	d = (static_cast<unsigned __int128>(borrow) << 64) | borrow;
	d += static_cast<unsigned __int128>(a) - b;
	*low = static_cast<uint64_t>(d);
	*high = static_cast<uint64_t>(d >> 64);
}
#endif

//! Unsigned subtraction with borrow of the given integers a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_subtract_with_borrow_1x1(uint32_t *low, uint32_t *high, uint32_t a, uint32_t b, uint32_t borrow) noexcept {
	uint64_t d;

	d = (static_cast<uint64_t>(borrow) << 32) | borrow;
	d += static_cast<uint64_t>(a) - b;
	*low = static_cast<uint32_t>(d);
	*high = static_cast<uint32_t>(d >> 32);
}

#if JSOP_WORD_SIZE == 64
//! Unsigned subtraction with borrow of the given double width integers a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_subtract_2x2(uint64_t *low, uint64_t *high, uint64_t a_low, uint64_t a_high, uint64_t b_low, uint64_t b_high) noexcept {
	unsigned __int128 a, b;

	a = (static_cast<unsigned __int128>(a_high) << 64) | a_low;
	b = (static_cast<unsigned __int128>(b_high) << 64) | b_low;
	a -= b;
	*low = static_cast<uint64_t>(a);
	*high = static_cast<uint64_t>(a >> 64);
}
#endif

//! Unsigned subtraction with borrow of the given double width integers a and b, and returns the result as a double width integer
JSOP_INLINE void jsop_uint_subtract_2x2(uint32_t *low, uint32_t *high, uint32_t a_low, uint32_t a_high, uint32_t b_low, uint32_t b_high) noexcept {
	uint64_t a, b;

	a = (static_cast<uint64_t>(a_high) << 32) | a_low;
	b = (static_cast<uint64_t>(b_high) << 32) | b_low;
	a -= b;
	*low = static_cast<uint32_t>(a);
	*high = static_cast<uint32_t>(a >> 32);
}

//! Adds b to the given double width integer
template <typename T>
JSOP_INLINE void jsop_uint_add_2x1_assign(T *low, T *high, T b) noexcept {
	jsop_uint_add_2x1(low, high, *low, *high, b);
}

//! Computes a * b + c and returns the result as a double width integer
template <typename T>
JSOP_INLINE void jsop_uint_multiply_add_1x1(T *low, T *high, T a, T b, T c) noexcept {
	T p_low, p_high;

	jsop_uint_multiply_1x1(&p_low, &p_high, a, b);
	jsop_uint_add_2x1(low, high, p_low, p_high, c);
}

//! Multiple the given double width integers a and b, and returns the result as a quad width integer
template <typename T>
JSOP_INLINE void jsop_uint_multiply_2x2(T *d0, T *d1, T *d2, T *d3, T a0, T a1, T b0, T b1) noexcept {
	T a0_b0_high;
	T a1_b0_low, a1_b0_high;
	T a0_b1_high;
	T a1_b1_low, a1_b1_high;

	jsop_uint_multiply_1x1(d0, &a0_b0_high, a0, b0);
	jsop_uint_multiply_add_1x1(&a1_b0_low, &a1_b0_high, a1, b0, a0_b0_high);
	jsop_uint_multiply_add_1x1(d1, &a0_b1_high, a0, b1, a1_b0_low);
	jsop_uint_multiply_add_1x1(&a1_b1_low, &a1_b1_high, a1, b1, a1_b0_high);
	jsop_uint_add_2x1(d2, d3, a1_b1_low, a1_b1_high, a0_b1_high);
}

//! Shifts the given double width integer left by n bits, and returns the result as a triple width integer
template <typename T>
JSOP_INLINE void jsop_uint_shift_left_x2(T *d0, T *d1, T *d2, T value_low, T value_high, int n) noexcept {
	assert(n > 0 && static_cast<unsigned>(n) < sizeof(T) * CHAR_BIT);

	*d2 = value_high >> (sizeof(T) * CHAR_BIT - n);
	*d1 = (value_high << n) | (value_low >> (sizeof(T) * CHAR_BIT - n));
	*d0 = value_low << n;
}

//! Shifts the given double width integer left by n bits, and returns the result as a double width integer
template <typename T>
JSOP_INLINE void jsop_uint_shift_left_x2(T *low, T *high, T value_low, T value_high, int n) noexcept {
	assert(n > 0 && static_cast<unsigned>(n) < sizeof(T) * CHAR_BIT);

	*high = (value_high << n) | (value_low >> (sizeof(T) * CHAR_BIT - n));
	*low = value_low << n;
}

//! Shifts the given value left by n bits, and returns the result as a double width integer
template <typename T>
JSOP_INLINE void jsop_uint_shift_left_x1(T *low, T *high, T value, int n) noexcept {
	assert(n > 0 && static_cast<unsigned>(n) < sizeof(T) * CHAR_BIT * 2);

	if (static_cast<unsigned>(n) >= sizeof(T) * CHAR_BIT) {
		*high = value << (n - sizeof(T) * CHAR_BIT);
		*low = 0;
	} else {
		*high = value >> (sizeof(T) * CHAR_BIT - n);
		*low = value << n;
	}
}

//! Shifts the given double width integer left by n bits
template <typename T>
JSOP_INLINE void jsop_uint_shift_left_x2_assign(T *low, T *high, int n) noexcept {
	return jsop_uint_shift_left_x2(low, high, *low, *high, n);
}

//! Shifts the given double width integer right by n bits, and returns the result as a double width integer
template <typename T>
JSOP_INLINE void jsop_uint_shift_right_x2(T *low, T *high, T value_low, T value_high, int n) noexcept {
	assert(n > 0 && static_cast<unsigned>(n) < sizeof(T) * CHAR_BIT);

	*low = (value_high << (sizeof(T) * CHAR_BIT - n)) | (value_low >> n);
	*high = value_high >> n;
}

//! Shifts the given double width integer right by n bits
template <typename T>
JSOP_INLINE void jsop_uint_shift_right_x2_assign(T *low, T *high, int n) noexcept {
	jsop_uint_shift_right_x2(low, high, *low, *high, n);
}

//! Multiplies the given multi-precision unsigned integer by the given integer, and returns the result as a multi-precision unsigned integer
template <typename T>
T *jsop_mp_uint_multiply_x1(T *d, const T *a, const T *a_end, T b) noexcept {
	T *d_i;
	const T *a_i;
	T carry;

	assert(d != a);

	jsop_uint_multiply_1x1(d, &carry, *a, b);
	for (a_i = a + 1, d_i = d + 1; a_i < a_end; ++a_i, ++d_i) {
		jsop_uint_multiply_add_1x1(d_i, &carry, *a_i, b, carry);
	}
	*d_i = carry;

	auto d_end = d_i;
	if (carry != 0) {
		++d_end;
	}
	return d_end;
}

//! Multiplies the given multi-precision unsigned integer by the given double width integer, and returns the result as a multi-precision unsigned integer
template <typename T>
T *jsop_mp_uint_multiply_x2(T *d, const T *a, const T *a_end, T b_low, T b_high) noexcept {
	T *d_i;
	const T *a_i;
	T carry, p_low, p_high;

	assert(d != a);

	//Multiply a by the low part of b
	jsop_uint_multiply_1x1(d, &carry, *a, b_low);
	for (a_i = a + 1, d_i = d + 1; a_i < a_end; ++a_i, ++d_i) {
		jsop_uint_multiply_add_1x1(d_i, &carry, *a_i, b_low, carry);
	}
	*d_i = carry;

	//Multiply a by the high part of b
	if (b_high != 0) {
		++d;
		jsop_uint_multiply_add_1x1(d, &carry, *a, b_high, *d);
		for (a_i = a + 1, d_i = d + 1; a_i != a_end; ++a_i, ++d_i) {
			jsop_uint_multiply_add_1x1(&p_low, &p_high, *a_i, b_high, carry);
			jsop_uint_add_2x1(d_i, &carry, p_low, p_high, *d_i);
		}
		*d_i = carry;
	}

	auto d_end = d_i;
	if (carry != 0) {
		++d_end;
	}
	return d_end;
}

//! Shifts the given integer by n bits, and returns the result as a multi-precision unsigned integer
template <typename T>
T *jsop_mp_uint_shift_left_x1(T *d, T value, unsigned n) noexcept {
	T *d_i;
	T *d_e;
	T high, low;

	assert(value != 0);

	d_e = d + (n / (sizeof(T) * CHAR_BIT));
	for (d_i = d; d_i != d_e; ++d_i) {
		*d_i = 0;
	}
	n %= sizeof(T) * CHAR_BIT;
	low = value << n;
	*d_e = low;
	++d_e;
	if (n > 0) {
		high = value >> (sizeof(T) * CHAR_BIT - n);
		if (high != 0) {
			*d_e = high;
			++d_e;
		}
	}
	return d_e;
}

//! Shifts the given double width integer by n bits, and returns the result as a multi-precision unsigned integer
template <typename T>
T *jsop_mp_uint_shift_left_x2(T *d, T value_l, T value_h, unsigned n) noexcept {
	T *d_i;
	T *d_e;
	T d0, d1, d2;

	assert(value_h != 0 || (value_h == 0 && value_l != 0));

	d_e = d + (n / (sizeof(T) * CHAR_BIT));
	for (d_i = d; d_i != d_e; ++d_i) {
		*d_i = 0;
	}
	n %= sizeof(T) * CHAR_BIT;
	if (n > 0) {
		jsop_uint_shift_left_x2(&d0, &d1, &d2, value_l, value_h, n);
		*d_e = d0;
		++d_e;
		if (d2 != 0) {
			*d_e = d1;
			*(d_e + 1) = d2;
			d_e += 2;
		} else if (d1 != 0) {
			*d_e = d1;
			++d_e;
		}
	} else {
		d0 = value_l;
		d1 = value_h;

		*d_e = d0;
		++d_e;
		if (d1 != 0) {
			*d_e = d1;
			++d_e;
		}
	}
	return d_e;
}

//! Subtracts the given multi-precision unsigned integer b from a
template <typename T>
void jsop_mp_uint_subtract_assign(T *a, T *a_end, const T *b, const T *b_end) noexcept {
	T *a_i;
	const T *b_i;
	T borrow;

	assert((a_end - a) >= (b_end - b));

	jsop_uint_subtract_1x1(a, &borrow, *a, *b);
	for (a_i = a + 1, b_i = b + 1; b_i != b_end; ++a_i, ++b_i) {
		jsop_uint_subtract_with_borrow_1x1(a_i, &borrow, *a_i, *b_i, borrow);
	}
	for (; borrow && a_i != a_end; ++a_i) {
		jsop_uint_subtract_1x1(a_i, &borrow, *a_i, 1);
	}
}

//! Subtracts the given multi-precision unsigned integers a and b
//! If a > b, return value > 0
//! If a == b, return value = 0
//! If a < b, return value < 0
template <typename T>
int jsop_mp_uint_compare(const T *a, const T *a_end, const T *b, const T *b_end) noexcept {
	const T *a_e;
	const T *a_i;
	const T *b_i;
	T digit_a, digit_b;
	size_t b_size;

	assert(a_end > a && b_end > b);

	b_size = b_end - b;
	a_e = a + b_size;
	for (a_i = a_end; a_i > a_e; --a_i) {
		if (*(a_i - 1) != 0) {
			return 1;
		}
	}
	for (a_i = a + b_size, b_i = b_end; b_i > b; --a_i, --b_i) {
		digit_a = *(a_i - 1);
		digit_b = *(b_i - 1);
		if (digit_a > digit_b) {
			return 1;
		} else if (digit_a < digit_b) {
			return -1;
		}
	}
	return 0;
}

#if JSOP_WORD_SIZE == 64
//! Rounds a 55 bit mantissa to 53 bits using round to nearest even, and updates the exponent if necessary
//! The remainder should be computed by oring all bits beyond the mantissa together
JSOP_INLINE void jsop_round_to_nearest_even(uint64_t *mantissa, int *exponent, uint64_t remainder) noexcept {
	remainder |= *mantissa & 4;
	*mantissa |= remainder != 0 ? 1 : 0;
	++*mantissa;
	*mantissa >>= 2;
	if ((*mantissa & (UINT64_C(1) << DBL_MANT_DIG)) != 0) {
		*mantissa >>= 1;
		++*exponent;
	}
}

//! Makes a double precision value from the given mantissa, exponent, and sign
JSOP_INLINE double jsop_make_double(uint64_t mantissa, int exponent, bool negative) noexcept {
	union {
		uint64_t u;
		double d;
	} ud;

	ud.u = (static_cast<uint64_t>(negative) << 63) |
		(static_cast<uint64_t>(exponent + (2 - DBL_MIN_EXP)) << (DBL_MANT_DIG - 1)) |
		(mantissa & ((UINT64_C(1) << (DBL_MANT_DIG - 1)) - 1U));
	return ud.d;
}

//! Makes a double precision value when the exponent is small enough such that the resulting value is a subnormal
JSOP_INLINE double jsop_make_subnormal_double(uint64_t mantissa, int exponent, uint64_t remainder, bool negative) noexcept {
	int remainder_bits;

	remainder_bits = (DBL_MIN_EXP - 1) - exponent;
	if (remainder_bits <= DBL_MANT_DIG) {
		remainder |= mantissa << (64 - remainder_bits);
		mantissa >>= remainder_bits;
		exponent = DBL_MIN_EXP - 2;

		//Round to nearest even
		remainder |= mantissa & 4;
		mantissa |= remainder != 0 ? 1 : 0;
		++mantissa;
		mantissa >>= 2;
		if ((mantissa & (UINT64_C(1) << (DBL_MANT_DIG - 1))) != 0) {
			exponent = DBL_MIN_EXP - 1;
		}

		return jsop_make_double(mantissa, exponent, negative);
	} else {
		return negative ? -0. : 0.;
	}
}

#else

//! Rounds a 55 bit mantissa to 53 bits using round to nearest even, and updates the exponent if necessary
//! The remainder should be computed by oring all bits beyond the mantissa together
JSOP_INLINE void jsop_round_to_nearest_even(uint32_t *mantissa_low, uint32_t *mantissa_high, int *exponent, uint32_t remainder) noexcept {
	remainder |= *mantissa_low & 4;
	*mantissa_low |= remainder != 0 ? 1 : 0;
	jsop_uint_add_2x1_assign(mantissa_low, mantissa_high, 1U);
	jsop_uint_shift_right_x2_assign(mantissa_low, mantissa_high, 2);
	if ((*mantissa_high & (1U << (DBL_MANT_DIG - 32))) != 0) {
		jsop_uint_shift_right_x2_assign(mantissa_low, mantissa_high, 1);
		++*exponent;
	}
}

//! Makes a double precision value from the given mantissa, exponent, and sign
JSOP_INLINE double jsop_make_double(uint32_t mantissa_low, uint32_t mantissa_high, int exponent, bool negative) noexcept {
	union {
		uint64_t u;
		double d;
	} ud;

	mantissa_high = (static_cast<uint32_t>(negative) << (32 - 1)) |
		((exponent + (2 - DBL_MIN_EXP)) << (DBL_MANT_DIG - 1 - 32)) |
		(mantissa_high & ((1U << (DBL_MANT_DIG - 1 - 32)) - 1U));
	ud.u = (static_cast<uint64_t>(mantissa_high) << 32) | mantissa_low;
	return ud.d;
}

//! Makes a double precision value when the exponent is small enough such that the resulting value is a subnormal
JSOP_INLINE double jsop_make_subnormal_double(uint32_t mantissa_low, uint32_t mantissa_high, int exponent, uint32_t remainder, bool negative) noexcept {
	int remainder_bits;

	remainder_bits = (DBL_MIN_EXP - 1) - exponent;
	if (remainder_bits <= DBL_MANT_DIG) {
		if (remainder_bits >= 32) {
			remainder |= mantissa_low;
			remainder_bits -= 32;
			if (remainder_bits > 0) {
				remainder |= mantissa_high << (32 - remainder_bits);
			}

			mantissa_low = mantissa_high >> remainder_bits;
			mantissa_high = 0;
		} else {
			remainder |= mantissa_low << (32 - remainder_bits);
			jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
		}

		exponent = DBL_MIN_EXP - 2;

		//Round to nearest even
		remainder |= mantissa_low & 4;
		mantissa_low |= remainder != 0 ? 1 : 0;
		jsop_uint_add_2x1_assign(&mantissa_low, &mantissa_high, 1U);
		jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, 2);
		if ((mantissa_high & (1U << (DBL_MANT_DIG - 1 - 32))) != 0) {
			exponent = DBL_MIN_EXP - 1;
		}

		return jsop_make_double(mantissa_low, mantissa_high, exponent, negative);
	}
	return negative ? -0. : 0.;
}

#endif

double jsop_decimal_to_double(uint64_t significand, int exponent, bool negative) noexcept {
#if JSOP_WORD_SIZE == 64
	uint64_t remainder, mantissa;
	int mantissa_bits, remainder_bits, final_exponent, reciprocal_exponent;
	unsigned abs_exponent;

	if (significand != 0) {
		if (exponent >= 0) {
#ifdef JSOP_USE_FP_MATH
			if (static_cast<unsigned>(exponent) < jsop_get_array_size(JsopPowersOfTen) && significand < (UINT64_C(1) << DBL_MANT_DIG)) {
				double product = static_cast<double>(static_cast<int64_t>(significand)) * JsopPowersOfTen[exponent];
				return negative ? -product : product;
			}
#endif

			if (static_cast<unsigned>(exponent) < jsop_get_array_size(JsopSmallPowersOfFive)) {
				jsop_uint_multiply_1x1(&remainder, &mantissa, significand, JsopSmallPowersOfFive[exponent]);
				if (mantissa != 0) {
					mantissa_bits = jsop_uint_count_significant_bits(mantissa);
					final_exponent = exponent + mantissa_bits + 64 - 1;
					remainder_bits = mantissa_bits - (DBL_MANT_DIG + 2);

					//NOTE: Remainder is not tracked exactly, since it just needs to tell if there is a remainder
					//The high and low parts of the remainder are ored together
					//with the last digit (for round to even)
					if (remainder_bits > 0) {
						remainder |= mantissa << (64 - remainder_bits);
						mantissa >>= remainder_bits;
					} else if (remainder_bits < 0) {
						jsop_uint_shift_left_x2_assign(&remainder, &mantissa, -remainder_bits);
					}
				} else {
					mantissa = remainder;
					remainder = 0;

					mantissa_bits = jsop_uint_count_significant_bits(mantissa);
					final_exponent = exponent + mantissa_bits - 1;
					remainder_bits = mantissa_bits - (DBL_MANT_DIG + 2);

					//NOTE: Remainder is not tracked exactly, since it just needs to tell if there is a remainder
					//The high and low parts of the remainder are ored together
					//with the last digit (for round to even)
					if (remainder_bits > 0) {
						remainder = mantissa << (64 - remainder_bits);
						mantissa >>= remainder_bits;
					} else {
						mantissa <<= -remainder_bits;
					}
				}

				jsop_round_to_nearest_even(&mantissa, &final_exponent, remainder);
				return jsop_make_double(mantissa, final_exponent, negative);
			} else if (exponent <= JSOP_MAX_EXPONENT_OF_FIVE) {
				uint64_t mpn_uints[JSOP_MPN_MAX_UINTS * 2];
				uint64_t *partial_product;
				uint64_t *full_product;
				uint64_t *full_product_end;

				partial_product = mpn_uints;
				full_product = jsop_mp_uint_multiply_x1(
					partial_product,
					JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(static_cast<unsigned>(exponent) / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE) - 1],
					JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(static_cast<unsigned>(exponent) / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE)],
					JsopSmallPowersOfFive[static_cast<unsigned>(exponent) & (JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE - 1)]);
				full_product_end = jsop_mp_uint_multiply_x1(
					full_product,
					partial_product,
					full_product,
					significand);

				remainder = *(full_product_end - 2);
				mantissa = *(full_product_end - 1);
				mantissa_bits = jsop_uint_count_significant_bits(mantissa);
				//Compute the exponent
				final_exponent = exponent + mantissa_bits + ((full_product_end - full_product) - 1) * 64 - 1;
				//Normalize the mantissa and the remainder
				remainder_bits = mantissa_bits - (DBL_MANT_DIG + 2);
				if (remainder_bits > 0) {
					//Parts of the mantissa belongs to the remainder
					remainder |= mantissa << (64 - remainder_bits);
					mantissa >>= remainder_bits;
				} else if (remainder_bits < 0) {
					//Parts of the remainder belongs to the mantissa
					jsop_uint_shift_left_x2_assign(&remainder, &mantissa, -remainder_bits);
				}
				assert(mantissa >= (UINT64_C(1) << (DBL_MANT_DIG + 1)) && mantissa < (UINT64_C(1) << (DBL_MANT_DIG + 2)));
				//Or the rest of the remainder together
				for (auto full_product_i = full_product; full_product_i < (full_product_end - 2); ++full_product_i) {
					remainder |= *full_product_i;
				}

				//Round and assemble the number
				jsop_round_to_nearest_even(&mantissa, &final_exponent, remainder);
				if (final_exponent < DBL_MAX_EXP) {
					return jsop_make_double(mantissa, final_exponent, negative);
				} else {
					return negative ? -HUGE_VAL : HUGE_VAL;
				}
			} else {
				return negative ? -HUGE_VAL : HUGE_VAL;
			}
		} else {
			abs_exponent = -exponent;
#ifdef JSOP_USE_FP_MATH
			if (abs_exponent < jsop_get_array_size(JsopPowersOfTen) && significand < (UINT64_C(1) << DBL_MANT_DIG)) {
				double product = static_cast<double>(static_cast<int64_t>(significand)) / JsopPowersOfTen[abs_exponent];
				return negative ? -product : product;
			}
#endif

			if (abs_exponent <= jsop_get_array_size(JsopNormalizedReciprocalExponentsOf5)) {
				if (significand != 1) {
					jsop_uint_multiply_1x1(&remainder, &mantissa, significand, JsopNormalizedReciprocalsOf5[abs_exponent - 1]);
					mantissa_bits = jsop_uint_count_significant_bits(mantissa);
					remainder_bits = mantissa_bits - (DBL_MANT_DIG + 2);
					reciprocal_exponent = JsopNormalizedReciprocalExponentsOf5[abs_exponent - 1];
					final_exponent = exponent - reciprocal_exponent + mantissa_bits + 64 - 1;
					if (remainder_bits < 0) {
						remainder_bits = -remainder_bits;
						mantissa = (mantissa << remainder_bits) | (remainder >> (64 - remainder_bits));
						remainder_bits = 64 - remainder_bits;
					} else {
						mantissa >>= remainder_bits;
						remainder_bits += 64;
					}
					assert(mantissa >= (UINT64_C(1) << (DBL_MANT_DIG + 1)) && mantissa < (UINT64_C(1) << (DBL_MANT_DIG + 2)));
					if (abs_exponent < jsop_get_array_size(JsopSmallPowersOfFive)) {
						auto denominator = JsopSmallPowersOfFive[abs_exponent];
						uint64_t difference;
						remainder_bits = reciprocal_exponent - remainder_bits;
						if (remainder_bits > 0) {
							uint64_t numerator_low, numerator_high;
							uint64_t qd_low, qd_high;
							uint64_t difference_high;

							remainder = 0;
							jsop_uint_shift_left_x1(&numerator_low, &numerator_high, significand, remainder_bits);
							jsop_uint_multiply_1x1(&qd_low, &qd_high, mantissa, denominator);
							jsop_uint_subtract_2x2(&difference, &difference_high, numerator_low, numerator_high, qd_low, qd_high);
							assert(difference_high == 0);
						} else if (remainder_bits < 0) {
							auto numerator = significand;
							remainder = numerator << (64 + remainder_bits);
							numerator >>= -remainder_bits;
							difference = numerator - mantissa * denominator;
						} else {
							remainder = 0;
							difference = significand - mantissa * denominator;
						}

						if (difference >= denominator) {
							++mantissa;
							if (mantissa >= (UINT64_C(1) << (DBL_MANT_DIG + 2))) {
								assert(mantissa % 2 == 0);
								mantissa >>= 1;
								++final_exponent;
							}
							difference -= denominator;
							assert(difference < denominator);
						}
						assert(mantissa >= (UINT64_C(1) << (DBL_MANT_DIG + 1)) && mantissa < (UINT64_C(1) << (DBL_MANT_DIG + 2)));
						remainder |= difference;

						jsop_round_to_nearest_even(&mantissa, &final_exponent, remainder);
						return jsop_make_double(mantissa, final_exponent, negative);
					} else {
						uint64_t uints[JSOP_MPN_MAX_UINTS * 3];
						uint64_t *denominator;
						uint64_t *denominator_end;
						uint64_t *qd;
						uint64_t *qd_end;
						uint64_t *difference;
						uint64_t *difference_end;

						denominator = uints;
						denominator_end = jsop_mp_uint_multiply_x1(
							denominator,
							JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(abs_exponent / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE) - 1],
							JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(abs_exponent / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE)],
							JsopSmallPowersOfFive[abs_exponent & (JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE - 1)]);

						qd = denominator_end;
						qd_end = jsop_mp_uint_multiply_x1(qd, denominator, denominator_end, mantissa);

						difference = qd_end;
						difference_end = jsop_mp_uint_shift_left_x1(difference, significand, JsopNormalizedReciprocalExponentsOf5[abs_exponent - 1] - remainder_bits);
						jsop_mp_uint_subtract_assign(difference, difference_end, qd, qd_end);
						auto compare_result = jsop_mp_uint_compare(difference, difference_end, denominator, denominator_end);
						if (compare_result >= 0) {
							++mantissa;
							if (mantissa >= (UINT64_C(1) << (DBL_MANT_DIG + 2))) {
								assert(mantissa % 2 == 0);
								mantissa >>= 1;
								++final_exponent;
							}
						}
						assert(mantissa >= (UINT64_C(1) << (DBL_MANT_DIG + 1)) && mantissa < (UINT64_C(1) << (DBL_MANT_DIG + 2)));
						remainder |= compare_result;
					}
				} else {
					mantissa = JsopNormalizedReciprocalsOf5[abs_exponent - 1] >> (64 - (DBL_MANT_DIG + 2));
					remainder = 1;
					final_exponent = exponent - JsopNormalizedReciprocalExponentsOf5[abs_exponent - 1] + 64 - 1;
				}

				if (final_exponent >= (DBL_MIN_EXP - 1)) {
					jsop_round_to_nearest_even(&mantissa, &final_exponent, remainder);
					return jsop_make_double(mantissa, final_exponent, negative);
				} else {
					return jsop_make_subnormal_double(mantissa, final_exponent, remainder, negative);
				}
			} else {
				return negative ? -0. : 0.;
			}
		}
	}
	return negative ? -0. : 0.;
#else
	uint32_t significand_low, significand_high;
	uint32_t power_of_five;
	uint32_t remainder, mantissa_low, mantissa_high;
	uint32_t reciprocal_low, reciprocal_high;
	int mantissa_high_bits, remainder_bits, final_exponent, reciprocal_exponent;
	unsigned abs_exponent;

	significand_low = static_cast<uint32_t>(significand);
	significand_high = static_cast<uint32_t>(significand >> 32);
	if (exponent >= 0) {
#ifdef JSOP_USE_FP_MATH
		if (static_cast<unsigned>(exponent) < jsop_get_array_size(JsopPowersOfTen) && significand_high < (1U << (DBL_MANT_DIG - 32))) {
			double product = static_cast<double>(static_cast<int64_t>(significand)) * JsopPowersOfTen[exponent];
			return negative ? -product : product;
		}
#endif

		if (static_cast<unsigned>(exponent) < jsop_get_array_size(JsopSmallPowersOfFive)) {
			power_of_five = JsopSmallPowersOfFive[exponent];
			if (significand_high != 0) {
				jsop_uint_multiply_1x1(&remainder, &mantissa_low, power_of_five, significand_low);
				jsop_uint_multiply_add_1x1(&mantissa_low, &mantissa_high, power_of_five, significand_high, mantissa_low);
				if (mantissa_high != 0) {
					mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_high);
					final_exponent = exponent + mantissa_high_bits + 2 * 32 - 1;
					remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
					if (remainder_bits > 0) {
						remainder |= mantissa_low << (32 - remainder_bits);
						jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
					} else if (remainder_bits < 0) {
						remainder_bits = -remainder_bits;
						jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
						mantissa_low |= remainder >> (32 - remainder_bits);
						remainder <<= remainder_bits;
					}
				} else {
					mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_low);
					final_exponent = exponent + mantissa_high_bits + 32 - 1;
					remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
					if (remainder_bits > 0) {
						jsop_uint_shift_right_x2(&mantissa_low, &mantissa_high, remainder, mantissa_low, remainder_bits);
						remainder <<= 32 - remainder_bits;
					} else {
						mantissa_high = mantissa_low;
						mantissa_low = remainder;
						remainder = 0;
						if (remainder_bits < 0) {
							jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, -remainder_bits);
						}
					}
				}
			} else if (significand_low != 0) {
				jsop_uint_multiply_1x1(&mantissa_low, &mantissa_high, power_of_five, significand_low);
				if (mantissa_high != 0) {
					mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_high);
					final_exponent = exponent + mantissa_high_bits + 32 - 1;
					remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
					if (remainder_bits > 0) {
						remainder = mantissa_low << (32 - remainder_bits);
						jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
					} else {
						remainder = 0;
						if (remainder_bits < 0) {
							jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, -remainder_bits);
						}
					}
				} else {
					mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_low);
					final_exponent = exponent + mantissa_high_bits - 1;
					remainder_bits = DBL_MANT_DIG + 2 - mantissa_high_bits;
					remainder = 0;
					jsop_uint_shift_left_x1(&mantissa_low, &mantissa_high, mantissa_low, remainder_bits);
				}
			} else {
				return negative ? -0. : 0.;
			}

			jsop_round_to_nearest_even(&mantissa_low, &mantissa_high, &final_exponent, remainder);
			return jsop_make_double(mantissa_low, mantissa_high, final_exponent, negative);
		} else if (significand_low != 0 || significand_high != 0) {
			if (exponent <= JSOP_MAX_EXPONENT_OF_FIVE) {
				uint32_t mpn_uints[JSOP_MPN_MAX_UINTS * 2];
				uint32_t *partial_product;
				uint32_t *full_product;
				uint32_t *full_product_end;

				partial_product = mpn_uints;
				full_product = jsop_mp_uint_multiply_x1(
					partial_product,
					JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(static_cast<unsigned>(exponent) / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE) - 1],
					JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(static_cast<unsigned>(exponent) / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE)],
					JsopSmallPowersOfFive[static_cast<unsigned>(exponent) & (JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE - 1)]);
				full_product_end = jsop_mp_uint_multiply_x2(
					full_product,
					partial_product,
					full_product,
					significand_low,
					significand_high);

				mantissa_low = *(full_product_end - 2);
				mantissa_high = *(full_product_end - 1);
				mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_high);
				final_exponent = exponent + mantissa_high_bits + ((full_product_end - full_product) - 1) * 32 - 1;
				remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
				full_product_end -= 2;
				if (remainder_bits > 0) {
					remainder = mantissa_low << (32 - remainder_bits);
					jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
				} else {
					remainder = 0;
					if (remainder_bits < 0) {
						remainder_bits = -remainder_bits;
						jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
						if (full_product_end != full_product) {
							remainder = *(full_product_end - 1);
							mantissa_low |= remainder >> (32 - remainder_bits);
							remainder <<= remainder_bits;
							--full_product_end;
						}
					}
				}
				for (; full_product_end != full_product; --full_product_end) {
					remainder |= *(full_product_end - 1);
				}

				jsop_round_to_nearest_even(&mantissa_low, &mantissa_high, &final_exponent, remainder);
				if (final_exponent < DBL_MAX_EXP) {
					return jsop_make_double(mantissa_low, mantissa_high, final_exponent, negative);
				} else {
					return !negative ? HUGE_VAL : -HUGE_VAL;
				}
			} else {
				return !negative ? HUGE_VAL : -HUGE_VAL;
			}
		} else {
			return negative ? -0. : 0.;
		}
	} else {
		abs_exponent = -exponent;
#ifdef JSOP_USE_FP_MATH
		if (abs_exponent < jsop_get_array_size(JsopPowersOfTen) && significand_high < (1U << (DBL_MANT_DIG- 32))) {
			double product = static_cast<double>(static_cast<int64_t>(significand)) / JsopPowersOfTen[abs_exponent];
			return negative ? -product : product;
		}
#endif

		if (abs_exponent <= jsop_get_array_size(JsopNormalizedReciprocalExponentsOf5)) {
			reciprocal_low = JsopNormalizedReciprocalsOf5[(abs_exponent - 1) * (64 / 32)];
			reciprocal_high = JsopNormalizedReciprocalsOf5[(abs_exponent - 1) * (64 / 32) + 1];
			reciprocal_exponent = JsopNormalizedReciprocalExponentsOf5[abs_exponent - 1];

			//Compute the initial quotient
			if (significand_high != 0) {
				uint32_t remainder_low, excess_bits;

				jsop_uint_multiply_2x2(&remainder_low,
					&remainder,
					&mantissa_low,
					&mantissa_high,
					reciprocal_low,
					reciprocal_high,
					significand_low,
					significand_high);
				if (mantissa_high != 0) {
					final_exponent = exponent + 3 * 32 - 1;
					excess_bits = 32;
				} else {
					mantissa_high = mantissa_low;
					mantissa_low = remainder;
					remainder = remainder_low;
					final_exponent = exponent + 2 * 32 - 1;
					excess_bits = 0;
				}

				mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_high);
				final_exponent += mantissa_high_bits - reciprocal_exponent;
				remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
				if (remainder_bits > 0) {
					jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
					remainder_bits += 32;
				} else if (remainder_bits < 0) {
					jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, -remainder_bits);
					remainder_bits = 32 + remainder_bits;
					mantissa_low |= remainder >> remainder_bits;
				} else {
					remainder_bits += 32;
				}
				remainder_bits += excess_bits;
			} else if (significand_low != 0) {
				jsop_uint_multiply_1x1(&remainder, &mantissa_low, reciprocal_low, significand_low);
				jsop_uint_multiply_add_1x1(&mantissa_low, &mantissa_high, reciprocal_high, significand_low, mantissa_low);

				if (mantissa_high != 0) {
					mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_high);
					final_exponent = exponent + mantissa_high_bits - reciprocal_exponent + 2 * 32 - 1;
					remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
					if (remainder_bits > 0) {
						jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
						remainder_bits += 32;
					} else if (remainder_bits < 0) {
						remainder_bits = -remainder_bits;
						jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, remainder_bits);
						remainder_bits = 32 - remainder_bits;
						mantissa_low |= remainder >> remainder_bits;
					} else {
						remainder_bits += 32;
					}
				} else {
					mantissa_high_bits = jsop_uint_count_significant_bits(mantissa_low);
					final_exponent = exponent + mantissa_high_bits - reciprocal_exponent + 32 - 1;
					remainder_bits = mantissa_high_bits - (DBL_MANT_DIG + 2 - 32);
					if (remainder_bits > 0) {
						jsop_uint_shift_right_x2(&mantissa_low, &mantissa_high, remainder, mantissa_low, remainder_bits);
					} else {
						mantissa_high = mantissa_low;
						mantissa_low = remainder;
						if (remainder_bits < 0) {
							jsop_uint_shift_left_x2_assign(&mantissa_low, &mantissa_high, -remainder_bits);
						}
					}
				}
			} else {
				return negative ? -0. : 0.;
			}

			uint32_t mpn_uints[JSOP_MPN_MAX_UINTS * 3];
			uint32_t *denominator;
			uint32_t *denominator_end;
			uint32_t *difference;
			uint32_t *difference_end;
			uint32_t *mpn_qd;
			uint32_t *mpn_qd_end;

			//Correct the quotient by checking the remainder
			denominator = mpn_uints;
			if (abs_exponent < jsop_get_array_size(JsopSmallPowersOfFive)) {
				*denominator = JsopSmallPowersOfFive[abs_exponent];
				denominator_end = denominator + 1;
			} else {
				denominator_end = jsop_mp_uint_multiply_x1(
					denominator,
					JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(abs_exponent / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE) - 1],
					JsopLargePowersOfFive + JsopLargePowersOfFiveOffsets[(abs_exponent / JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE)],
					JsopSmallPowersOfFive[abs_exponent & (JSOP_MPN_NUMBER_OF_SMALL_POWERS_OF_FIVE - 1)]);
			}

			remainder = 0;
			difference = denominator_end;
			if (reciprocal_exponent >= remainder_bits) {
				difference_end = jsop_mp_uint_shift_left_x2(difference, significand_low, significand_high, static_cast<unsigned>(reciprocal_exponent - remainder_bits));
			} else {
				remainder = significand_low << (32 + reciprocal_exponent - remainder_bits);
				jsop_uint_shift_right_x2(difference, difference + 1, significand_low, significand_high, remainder_bits - reciprocal_exponent);
				difference_end = difference + 2;
			}
			mpn_qd = difference_end;
			mpn_qd_end = jsop_mp_uint_multiply_x2(mpn_qd, denominator, denominator_end, mantissa_low, mantissa_high);
			jsop_mp_uint_subtract_assign(difference, difference_end, mpn_qd, mpn_qd_end);
			auto compare_result = jsop_mp_uint_compare(difference, difference_end, denominator, denominator_end);
			if (compare_result >= 0) {
				jsop_uint_add_2x1_assign(&mantissa_low, &mantissa_high, 1U);
				if (mantissa_high >= (1U << (DBL_MANT_DIG + 2 - 32))) {
					assert(mantissa_low % 2 == 0);
					jsop_uint_shift_right_x2_assign(&mantissa_low, &mantissa_high, 1);
					++final_exponent;
				}
			}
			remainder |= compare_result;

			if (final_exponent >= (DBL_MIN_EXP - 1)) {
				jsop_round_to_nearest_even(&mantissa_low, &mantissa_high, &final_exponent, remainder);
				return jsop_make_double(mantissa_low, mantissa_high, final_exponent, negative);
			} else {
				return jsop_make_subnormal_double(mantissa_low, mantissa_high, final_exponent, remainder, negative);
			}
		} else {
			return negative ? -0. : 0.;
		}
	}
	return negative ? -0. : 0.;
#endif
}

double jsop_hexadecimal_to_double(uint64_t significand, int exponent, bool negative) noexcept {
#if JSOP_WORD_SIZE == 64
	uint64_t mantissa, remainder;
	int n_mantissa_bits, n_remainder_bits, final_exponent;

	mantissa = significand;
	if (mantissa != 0) {
		n_mantissa_bits = jsop_uint_count_significant_bits(mantissa);
		n_remainder_bits = n_mantissa_bits - (DBL_MANT_DIG + 2);

		remainder = 0;
		if (n_remainder_bits <= 0) {
			mantissa <<= -n_remainder_bits;
		} else {
			remainder = mantissa << (64 - n_remainder_bits);
			mantissa >>= n_remainder_bits;
		}
		final_exponent = exponent + n_mantissa_bits - 1;

		//Check if exponent is big enough
		if (final_exponent >= (DBL_MIN_EXP - 1)) {
			//Round and check overflow
			jsop_round_to_nearest_even(&mantissa, &final_exponent, remainder);
			if (final_exponent < DBL_MAX_EXP) {
				return jsop_make_double(mantissa, final_exponent, negative);
			} else {
				return !negative ? HUGE_VAL : -HUGE_VAL;
			}
		} else {
			return jsop_make_subnormal_double(mantissa, final_exponent, remainder, negative);
		}
	} else {
		return negative ? -0. : 0.;
	}
#else
	uint32_t mantissa_l, mantissa_h, remainder;
	int mantissa_h_bits, remainder_bits, final_exponent;

	mantissa_l = static_cast<uint32_t>(significand);
	mantissa_h = static_cast<uint32_t>(significand >> 32);
	remainder = 0;
	if (mantissa_h != 0) {
		mantissa_h_bits = jsop_uint_count_significant_bits(mantissa_h);
		remainder_bits = mantissa_h_bits - (DBL_MANT_DIG + 2 - 32);

		if (remainder_bits < 0) {
			jsop_uint_shift_left_x2_assign(&mantissa_l, &mantissa_h, -remainder_bits);
		} else if (remainder_bits > 0) {
			remainder = mantissa_l << (32 - remainder_bits);
			jsop_uint_shift_right_x2_assign(&mantissa_l, &mantissa_h, remainder_bits);
		}
		final_exponent = exponent + mantissa_h_bits + 32 - 1;
	} else if (mantissa_l != 0) {
		mantissa_h = mantissa_l;
		mantissa_l = 0;

		mantissa_h_bits = jsop_uint_count_significant_bits(mantissa_h);
		remainder_bits = mantissa_h_bits - (DBL_MANT_DIG + 2 - 32);

		if (remainder_bits < 0) {
			jsop_uint_shift_left_x2_assign(&mantissa_l, &mantissa_h, -remainder_bits);
		} else if (remainder_bits > 0) {
			jsop_uint_shift_right_x2_assign(&mantissa_l, &mantissa_h, remainder_bits);
		}
		final_exponent = exponent + mantissa_h_bits - 1;
	} else {
		return negative ? -0. : 0.;
	}

	//Check if exponent is big enough
	if (final_exponent >= (DBL_MIN_EXP - 1)) {
		jsop_round_to_nearest_even(&mantissa_l, &mantissa_h, &final_exponent, remainder);
		//Check overflow
		if (final_exponent < DBL_MAX_EXP) {
			return jsop_make_double(mantissa_l, mantissa_h, final_exponent, negative);
		} else {
			return !negative ? HUGE_VAL : -HUGE_VAL;
		}
	} else {
		remainder_bits = (DBL_MIN_EXP - 1) - final_exponent;
		if (remainder_bits <= DBL_MANT_DIG) {
			if (remainder_bits >= 32) {
				remainder |= mantissa_l;
				remainder_bits -= 32;
				if (remainder_bits > 0) {
					remainder |= mantissa_h << (32 - remainder_bits);
				}

				mantissa_l = mantissa_h >> remainder_bits;
				mantissa_h = 0;
			} else {
				remainder |= mantissa_l << (32 - remainder_bits);
				jsop_uint_shift_right_x2_assign(&mantissa_l, &mantissa_h, remainder_bits);
			}

			final_exponent = DBL_MIN_EXP - 2;

			//Round to nearest even
			remainder |= mantissa_l & 4;
			mantissa_l |= remainder != 0 ? 1 : 0;
			jsop_uint_add_2x1_assign(&mantissa_l, &mantissa_h, 1U);
			jsop_uint_shift_right_x2_assign(&mantissa_l, &mantissa_h, 2);
			if ((mantissa_h & (1U << (DBL_MANT_DIG - 1 - 32))) != 0) {
				final_exponent = DBL_MIN_EXP - 1;
			}

			return jsop_make_double(mantissa_l, mantissa_h, final_exponent, negative);
		} else {
			return negative ? -0. : 0.;
		}
	}
#endif
}
